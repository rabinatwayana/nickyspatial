{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NickySpatial","text":"<p>An open-source object-based image analysis library for remote sensing.</p> Category Badge Build Code Quality Documentation Package Info Community <p>[!WARNING] This project is under active development and lot of its functionality is still in my head yet to code.</p> <p>Find Demo Frontend Here : https://nickyspatial-gpoqz.ondigitalocean.app/</p>"},{"location":"#description","title":"Description","text":"<p>NickySpatial is a Python package that provides object-based image analysis (OBIA) functionality similar to commercial software like eCognition. It allows users to segment geospatial imagery into meaningful objects, calculate statistics, and apply rule-based classification.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>nickyspatial/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 io/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 raster.py       # Raster I/O\n\u2502   \u2514\u2500\u2500 vector.py       # Vector I/O\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 layer.py        # Layer class and management\n\u2502   \u251c\u2500\u2500 segmentation.py # Segmentation algorithms\n\u2502   \u2514\u2500\u2500 rules.py        # Rule engine\n|   \u2514\u2500\u2500 classifier.py   # Classification algorithms\n\u251c\u2500\u2500 stats/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 basic.py        # Basic statistics (min, max, mean, etc.)\n\u2502   \u251c\u2500\u2500 spatial.py      # Spatial statistics (area, perimeter, etc.)\n\u2502   \u2514\u2500\u2500 spectral.py     # Spectral indices (NDVI, etc.)\n\u251c\u2500\u2500 filters/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 spatial.py      # Spatial filters (smoothing, merging)\n\u2502   \u2514\u2500\u2500 spectral.py     # Spectral filters (band math)\n\u251c\u2500\u2500 viz/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 maps.py         # Map visualization\n\u2502   \u2514\u2500\u2500 charts.py       # Statistical charts\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 helpers.py      # Helper functions\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install nickyspatial\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import nickyspatial as ns\n TODO : add sample computation here\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed documentation and examples, see the documentation website. Deepwiki also provides documentation quite detailed , Do check it out if you like</p>"},{"location":"#examples","title":"Examples","text":"<p>Check out the 'examples' directory for more examples:</p> <p>TODO : Add example scripts here</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Follow dev setup guide &amp; Please feel free to submit a Pull Request.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Inspired by the functionality of eCognition and other OBIA methodologies</li> <li>Built on top of powerful open-source libraries like numpy, rasterio, scikit-image, and GeoPandas</li> <li>Nicky  : Nicky is my belated dog and I named this package in his memory!     </li> </ul>"},{"location":"#contributors","title":"Contributors","text":""},{"location":"dev/","title":"Development Setup","text":"<p>Welcome to the development guide for nickyspatial! This guide will help you get up and running quickly, while also explaining the tools and processes we use.</p>"},{"location":"dev/#1-install-uv","title":"1. Install UV","text":"<p>We use UV because it is freaking fast and simplifies dependency management. UV streamlines the installation and synchronization of dependencies, making development smoother and more efficient.</p> <p>Install UV by running:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre>"},{"location":"dev/#2-sync-project-dependencies","title":"2. Sync Project Dependencies","text":"<p>Once UV is installed, install the project dependencies directly into your virtual environment (<code>.venv</code>) with:</p> <pre><code>uv sync\n</code></pre> <p>This command reads project's configuration (i.e. <code>pyproject.toml</code>) and ensures that all required libraries are installed with the correct versions.</p>"},{"location":"dev/#3-install-pre-commit-hooks","title":"3. Install Pre-commit Hooks","text":"<p>We use pre-commit hooks to ensure code quality and consistency across the project. Our pre-commit configuration includes:</p> <ul> <li>UV Lock: Ensures locking of dependency versions.</li> <li>Ruff Hooks (linter and formatter): Ruff is used for linting and formatting. It helps catch issues and enforces a consistent code style.</li> <li>Commitizen: Helps enforce conventional commit messages for better project history.</li> </ul> <p>To set up these hooks, run:</p> <pre><code>pre-commit install\n</code></pre> <p>This will automatically run the following on every commit:</p> <ul> <li>uv-lock: Validates your UV lock file.</li> <li>ruff: Checks code style and formatting.</li> <li>commitizen: Validates commit messages against the conventional commits specification.</li> </ul>"},{"location":"dev/#4-getting-started","title":"4. Getting Started","text":"<p>Once you have UV installed, dependencies synced, and pre-commit hooks set, you\u2019re ready for development. A typical workflow might look like:</p> <ul> <li>Work on a feature or bug fix. Just tell other people what you will be working on in issues</li> <li>Run your tests \u2013 our project uses Pytest for testing.</li> <li>Commit your changes \u2013 pre-commit hooks ensure that your code meets our quality standards and that your commit messages follow the Conventional Commits guidelines.</li> <li>Submit your PR - Create a branch with suitable name as per as your changes and raise PR</li> </ul>"},{"location":"dev/#bring-up-frontend","title":"Bring up frontend","text":"<pre><code>uv run streamlit run streamlit.py\n</code></pre>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#nickyspatial--nickyspatial-an-open-source-object-based-image-analysis-library-for-remote-sensing","title":"NickySpatial: An open-source object-based image analysis library for remote sensing","text":"<p>NickySpatial is a Python package for object-based image analysis, providing functionality similar to commercial software like eCognition.</p> <p>Key features: - Multiresolution segmentation - Object-based analysis - Rule-based classification - Statistics calculation - Integration with geospatial data formats</p>"},{"location":"reference/#nickyspatialcore","title":"<code>nickyspatial.core</code>","text":"<p>The core package encompasses fundamental data structures and algorithms for nickyspatial.</p> <p>It helps define the building blocks like layers, segmentation methods, and rule-based logic for object analysis workflows.</p> <p>Implements supervised classification algorithms to classify the segments.</p> <p>Defines the Layer class and related functionality for organizing geospatial data.</p> <p>A layer can represent a conceptual container for a vector object which is tightly coupled with underlying raster data, allowing additional metadata or processing logic to be attached making sure heirarchical relationships are maintained. This module provides the Layer and LayerManager classes, which manage layers of geospatial data, including segmentation results, classifications,and filters. Layers can be created, copied, and manipulated, and they support attaching functions to calculate additional properties.</p> <p>Provides a rule engine for object-based analysis, where segments or layers are processed according to custom logic.</p> <p>Main idea here is to allow encode expert rules that can be applied to object segments which are layers in a nickyspatial context. So rules are tied up to the layers , they can be attached or revoked or executed multiple items</p> <p>Developers can define domain-specific rules to classify or merge features based on attributes. This module includes the Rule and RuleSet classes, which allow users to create, manage, and apply rules to layers. The RuleSet class can be used to group multiple rules together, and the execute method applies these rules to a given layer. The rules can be defined using string expressions that can be evaluated using the numexpr library for performance.</p>"},{"location":"reference/#nickyspatial.core.classifier.SupervisedClassifier","title":"<code>SupervisedClassifier</code>","text":"<p>Implementation of Supervised Classification algorithm.</p> Source code in <code>nickyspatial/core/classifier.py</code> <pre><code>class SupervisedClassifier:\n    \"\"\"Implementation of Supervised Classification algorithm.\"\"\"\n\n    # TODO: name vs layer_name\n\n    def __init__(self, name=None, classifier_type=\"Random Forest\", classifier_params=None):\n        \"\"\"Initialize the segmentation algorithm.\n\n        Parameters:\n        -----------\n        scale : str\n            classifier type name eg: RF for Random Forest, SVC for Support Vector Classifier\n        classifier_params : dict\n           additional parameters relayed to classifier\n        \"\"\"\n        self.classifier_type = classifier_type\n        self.classifier_params = classifier_params\n        self.training_layer = None\n        self.classifier = None\n        self.name = name if name else \"Supervised_Classification\"\n        self.features = None\n\n    def _training_sample(self, layer, samples):\n        \"\"\"Create vector objects from segments.\n\n        Parameters:\n        -----------\n        samples : dict\n            key: class_name\n            values: list of segment_ids\n            eg: {\"cropland\":[1,2,3],\"built-up\":[4,5,6]}\n\n        Returns:\n        --------\n        segment_objects : geopandas.GeoDataFrame\n            GeoDataFrame with segment polygons\n        \"\"\"\n        layer[\"classification\"] = None\n\n        for class_name in samples.keys():\n            layer.loc[layer[\"segment_id\"].isin(samples[class_name]), \"classification\"] = class_name\n\n        layer = layer[layer[\"classification\"].notna()]\n        self.training_layer = layer\n        return layer\n\n    def _train(self, features):\n        \"\"\"Calculate statistics for segments based on image data.\n\n        Parameters:\n        -----------\n        layer : Layer\n            Layer containing segments\n        image_data : numpy.ndarray\n            Array with raster data values (bands, height, width)\n        bands : list of str\n            Names of the bands\n        \"\"\"\n        self.features = features\n        if not self.features:\n            self.features = self.training_layer.columns\n        self.features = [col for col in self.features if col not in [\"segment_id\", \"classification\", \"geometry\"]]\n        x = self.training_layer[self.features]\n\n        y = self.training_layer[\"classification\"]\n\n        if self.classifier_type == \"Random Forest\":\n            self.classifier = RandomForestClassifier(**self.classifier_params)\n            self.classifier.fit(x, y)\n            feature_importances = pd.Series(self.classifier.feature_importances_, index=self.features) * 100\n            feature_importances = feature_importances.sort_values(ascending=False)\n\n        test_accuracy = self.classifier.oob_score_\n        # print(\"OOB Score:\", self.classifier.oob_score_)\n\n        return self.classifier, test_accuracy, feature_importances\n\n    def _prediction(self, layer):\n        \"\"\"Perform classification prediction on input layer features.\n\n        Parameters\n        ----------\n        layer : geopandas.GeoDataFrame\n            Input data containing at least a 'segment_id' and 'geometry' column, along with\n            feature columns required by the classifier. If a 'classification' column does not\n            exist, it will be created.\n\n        Returns:\n        -------\n        The input layer with an updated 'classification' column containing predicted labels.\n\n        \"\"\"\n        layer[\"classification\"] = \"\"\n        # if not features:\n        #     x = layer.drop(columns=[\"segment_id\", \"classification\", \"geometry\"], errors=\"ignore\")\n        # else:\n        x = layer[self.features]\n\n        # print(layer.columns)\n        # x = layer.drop(columns=[\"segment_id\", \"classification\", \"geometry\"], errors=\"ignore\")\n\n        predictions = self.classifier.predict(x)\n        layer.loc[layer[\"classification\"] == \"\", \"classification\"] = predictions\n        return layer\n\n    def execute(self, source_layer, samples, layer_manager=None, layer_name=None, features=None):\n        \"\"\"Execute the supervised classification workflow on the source layer.\n\n        This method creates a new layer by copying the input source layer, training a classifier\n        using provided samples, predicting classifications, and storing the results in a new layer.\n        Optionally, the resulting layer can be added to a layer manager.\n\n        Parameters\n        ----------\n        source_layer : Layer\n            The input layer containing spatial objects and metadata (transform, CRS, raster).\n        samples : dict\n            A dictionary of training samples where keys are class labels and values are lists\n            of segment IDs or features used for training. Default is an empty dictionary.\n        layer_manager : LayerManager, optional\n            An optional layer manager object used to manage and store the resulting layer.\n        layer_name : str, optional\n            The name to assign to the resulting classified layer.\n\n        Returns:\n        -------\n        Layer\n            A new Layer object containing the predicted classifications, copied metadata from\n            the source layer, and updated attributes.\n        \"\"\"\n        result_layer = Layer(name=layer_name, parent=source_layer, type=\"merged\")\n        result_layer.transform = source_layer.transform\n        result_layer.crs = source_layer.crs\n        result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n        layer = source_layer.objects.copy()\n        self._training_sample(layer, samples)\n        _, accuracy, feature_importances = self._train(features)\n\n        layer = self._prediction(layer)\n\n        result_layer.objects = layer\n\n        result_layer.metadata = {\n            \"supervised classification\": self.name,\n        }\n\n        if layer_manager:\n            layer_manager.add_layer(result_layer)\n\n        return result_layer, accuracy, feature_importances\n</code></pre>"},{"location":"reference/#nickyspatial.core.classifier.SupervisedClassifier.__init__","title":"<code>__init__(name=None, classifier_type='Random Forest', classifier_params=None)</code>","text":"<p>Initialize the segmentation algorithm.</p>"},{"location":"reference/#nickyspatial.core.classifier.SupervisedClassifier.__init__--parameters","title":"Parameters:","text":"<p>scale : str     classifier type name eg: RF for Random Forest, SVC for Support Vector Classifier classifier_params : dict    additional parameters relayed to classifier</p> Source code in <code>nickyspatial/core/classifier.py</code> <pre><code>def __init__(self, name=None, classifier_type=\"Random Forest\", classifier_params=None):\n    \"\"\"Initialize the segmentation algorithm.\n\n    Parameters:\n    -----------\n    scale : str\n        classifier type name eg: RF for Random Forest, SVC for Support Vector Classifier\n    classifier_params : dict\n       additional parameters relayed to classifier\n    \"\"\"\n    self.classifier_type = classifier_type\n    self.classifier_params = classifier_params\n    self.training_layer = None\n    self.classifier = None\n    self.name = name if name else \"Supervised_Classification\"\n    self.features = None\n</code></pre>"},{"location":"reference/#nickyspatial.core.classifier.SupervisedClassifier.execute","title":"<code>execute(source_layer, samples, layer_manager=None, layer_name=None, features=None)</code>","text":"<p>Execute the supervised classification workflow on the source layer.</p> <p>This method creates a new layer by copying the input source layer, training a classifier using provided samples, predicting classifications, and storing the results in a new layer. Optionally, the resulting layer can be added to a layer manager.</p>"},{"location":"reference/#nickyspatial.core.classifier.SupervisedClassifier.execute--parameters","title":"Parameters","text":"<p>source_layer : Layer     The input layer containing spatial objects and metadata (transform, CRS, raster). samples : dict     A dictionary of training samples where keys are class labels and values are lists     of segment IDs or features used for training. Default is an empty dictionary. layer_manager : LayerManager, optional     An optional layer manager object used to manage and store the resulting layer. layer_name : str, optional     The name to assign to the resulting classified layer.</p>"},{"location":"reference/#nickyspatial.core.classifier.SupervisedClassifier.execute--returns","title":"Returns:","text":"<p>Layer     A new Layer object containing the predicted classifications, copied metadata from     the source layer, and updated attributes.</p> Source code in <code>nickyspatial/core/classifier.py</code> <pre><code>def execute(self, source_layer, samples, layer_manager=None, layer_name=None, features=None):\n    \"\"\"Execute the supervised classification workflow on the source layer.\n\n    This method creates a new layer by copying the input source layer, training a classifier\n    using provided samples, predicting classifications, and storing the results in a new layer.\n    Optionally, the resulting layer can be added to a layer manager.\n\n    Parameters\n    ----------\n    source_layer : Layer\n        The input layer containing spatial objects and metadata (transform, CRS, raster).\n    samples : dict\n        A dictionary of training samples where keys are class labels and values are lists\n        of segment IDs or features used for training. Default is an empty dictionary.\n    layer_manager : LayerManager, optional\n        An optional layer manager object used to manage and store the resulting layer.\n    layer_name : str, optional\n        The name to assign to the resulting classified layer.\n\n    Returns:\n    -------\n    Layer\n        A new Layer object containing the predicted classifications, copied metadata from\n        the source layer, and updated attributes.\n    \"\"\"\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"merged\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n    result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n    layer = source_layer.objects.copy()\n    self._training_sample(layer, samples)\n    _, accuracy, feature_importances = self._train(features)\n\n    layer = self._prediction(layer)\n\n    result_layer.objects = layer\n\n    result_layer.metadata = {\n        \"supervised classification\": self.name,\n    }\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer, accuracy, feature_importances\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.Layer","title":"<code>Layer</code>","text":"<p>A Layer represents a set of objects (segments or classification results) with associated properties.</p> <p>Layers can be derived from segmentation, rule application, or filters. Each layer can have functions attached to calculate additional properties.</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>class Layer:\n    \"\"\"A Layer represents a set of objects (segments or classification results) with associated properties.\n\n    Layers can be derived from segmentation, rule application, or filters.\n    Each layer can have functions attached to calculate additional properties.\n    \"\"\"\n\n    def __init__(self, name=None, parent=None, type=\"generic\"):\n        \"\"\"Initialize a Layer.\n\n        Parameters:\n        -----------\n        name : str, optional\n            Name of the layer. If None, a unique name will be generated.\n        parent : Layer, optional\n            Parent layer that this layer is derived from.\n        type : str\n            Type of layer: \"segmentation\", \"classification\", \"filter\", or \"generic\"\n        \"\"\"\n        self.id = str(uuid.uuid4())\n        self.name = name if name else f\"Layer_{self.id[:8]}\"\n        self.parent = parent\n        self.type = type\n        self.created_at = pd.Timestamp.now()\n\n        self.raster = None\n        self.objects = None\n        self.metadata = {}\n        self.transform = None\n        self.crs = None\n\n        self.attached_functions = {}\n\n    def attach_function(self, function, name=None, **kwargs):\n        \"\"\"Attach a function to this layer and execute it.\n\n        Parameters:\n        -----------\n        function : callable\n            Function to attach and execute\n        name : str, optional\n            Name for this function. If None, uses function.__name__\n        **kwargs : dict\n            Arguments to pass to the function\n\n        Returns:\n        --------\n        self : Layer\n            Returns self for chaining\n        \"\"\"\n        func_name = name if name else function.__name__\n\n        result = function(self, **kwargs)\n\n        self.attached_functions[func_name] = {\n            \"function\": function,\n            \"args\": kwargs,\n            \"result\": result,\n        }\n\n        return self\n\n    def get_function_result(self, function_name):\n        \"\"\"Get the result of an attached function.\n\n        Parameters:\n        -----------\n        function_name : str\n            Name of the attached function\n\n        Returns:\n        --------\n        result : any\n            Result of the function\n        \"\"\"\n        if function_name not in self.attached_functions:\n            raise ValueError(f\"Function '{function_name}' not attached to this layer\")\n\n        return self.attached_functions[function_name][\"result\"]\n\n    def copy(self):\n        \"\"\"Create a copy of this layer.\n\n        Returns:\n        --------\n        layer_copy : Layer\n            Copy of this layer\n        \"\"\"\n        new_layer = Layer(name=f\"{self.name}_copy\", parent=self.parent, type=self.type)\n\n        if self.raster is not None:\n            new_layer.raster = self.raster.copy()\n\n        if self.objects is not None:\n            new_layer.objects = self.objects.copy()\n\n        new_layer.metadata = self.metadata.copy()\n        new_layer.transform = self.transform\n        new_layer.crs = self.crs\n\n        return new_layer\n\n    def __str__(self):\n        \"\"\"String representation of the layer.\"\"\"\n        if self.objects is not None:\n            num_objects = len(self.objects)\n        else:\n            num_objects = 0\n\n        parent_name = self.parent.name if self.parent else \"None\"\n\n        return f\"Layer '{self.name}' (type: {self.type}, parent: {parent_name}, objects: {num_objects})\"\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.Layer.__init__","title":"<code>__init__(name=None, parent=None, type='generic')</code>","text":"<p>Initialize a Layer.</p>"},{"location":"reference/#nickyspatial.core.layer.Layer.__init__--parameters","title":"Parameters:","text":"<p>name : str, optional     Name of the layer. If None, a unique name will be generated. parent : Layer, optional     Parent layer that this layer is derived from. type : str     Type of layer: \"segmentation\", \"classification\", \"filter\", or \"generic\"</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def __init__(self, name=None, parent=None, type=\"generic\"):\n    \"\"\"Initialize a Layer.\n\n    Parameters:\n    -----------\n    name : str, optional\n        Name of the layer. If None, a unique name will be generated.\n    parent : Layer, optional\n        Parent layer that this layer is derived from.\n    type : str\n        Type of layer: \"segmentation\", \"classification\", \"filter\", or \"generic\"\n    \"\"\"\n    self.id = str(uuid.uuid4())\n    self.name = name if name else f\"Layer_{self.id[:8]}\"\n    self.parent = parent\n    self.type = type\n    self.created_at = pd.Timestamp.now()\n\n    self.raster = None\n    self.objects = None\n    self.metadata = {}\n    self.transform = None\n    self.crs = None\n\n    self.attached_functions = {}\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.Layer.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the layer.</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def __str__(self):\n    \"\"\"String representation of the layer.\"\"\"\n    if self.objects is not None:\n        num_objects = len(self.objects)\n    else:\n        num_objects = 0\n\n    parent_name = self.parent.name if self.parent else \"None\"\n\n    return f\"Layer '{self.name}' (type: {self.type}, parent: {parent_name}, objects: {num_objects})\"\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.Layer.attach_function","title":"<code>attach_function(function, name=None, **kwargs)</code>","text":"<p>Attach a function to this layer and execute it.</p>"},{"location":"reference/#nickyspatial.core.layer.Layer.attach_function--parameters","title":"Parameters:","text":"<p>function : callable     Function to attach and execute name : str, optional     Name for this function. If None, uses function.name **kwargs : dict     Arguments to pass to the function</p>"},{"location":"reference/#nickyspatial.core.layer.Layer.attach_function--returns","title":"Returns:","text":"<p>self : Layer     Returns self for chaining</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def attach_function(self, function, name=None, **kwargs):\n    \"\"\"Attach a function to this layer and execute it.\n\n    Parameters:\n    -----------\n    function : callable\n        Function to attach and execute\n    name : str, optional\n        Name for this function. If None, uses function.__name__\n    **kwargs : dict\n        Arguments to pass to the function\n\n    Returns:\n    --------\n    self : Layer\n        Returns self for chaining\n    \"\"\"\n    func_name = name if name else function.__name__\n\n    result = function(self, **kwargs)\n\n    self.attached_functions[func_name] = {\n        \"function\": function,\n        \"args\": kwargs,\n        \"result\": result,\n    }\n\n    return self\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.Layer.copy","title":"<code>copy()</code>","text":"<p>Create a copy of this layer.</p>"},{"location":"reference/#nickyspatial.core.layer.Layer.copy--returns","title":"Returns:","text":"<p>layer_copy : Layer     Copy of this layer</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def copy(self):\n    \"\"\"Create a copy of this layer.\n\n    Returns:\n    --------\n    layer_copy : Layer\n        Copy of this layer\n    \"\"\"\n    new_layer = Layer(name=f\"{self.name}_copy\", parent=self.parent, type=self.type)\n\n    if self.raster is not None:\n        new_layer.raster = self.raster.copy()\n\n    if self.objects is not None:\n        new_layer.objects = self.objects.copy()\n\n    new_layer.metadata = self.metadata.copy()\n    new_layer.transform = self.transform\n    new_layer.crs = self.crs\n\n    return new_layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.Layer.get_function_result","title":"<code>get_function_result(function_name)</code>","text":"<p>Get the result of an attached function.</p>"},{"location":"reference/#nickyspatial.core.layer.Layer.get_function_result--parameters","title":"Parameters:","text":"<p>function_name : str     Name of the attached function</p>"},{"location":"reference/#nickyspatial.core.layer.Layer.get_function_result--returns","title":"Returns:","text":"<p>result : any     Result of the function</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def get_function_result(self, function_name):\n    \"\"\"Get the result of an attached function.\n\n    Parameters:\n    -----------\n    function_name : str\n        Name of the attached function\n\n    Returns:\n    --------\n    result : any\n        Result of the function\n    \"\"\"\n    if function_name not in self.attached_functions:\n        raise ValueError(f\"Function '{function_name}' not attached to this layer\")\n\n    return self.attached_functions[function_name][\"result\"]\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.LayerManager","title":"<code>LayerManager</code>","text":"<p>Manages a collection of layers and their relationships.</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>class LayerManager:\n    \"\"\"Manages a collection of layers and their relationships.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the layer manager.\"\"\"\n        self.layers = {}\n        self.active_layer = None\n\n    def add_layer(self, layer, set_active=True):\n        \"\"\"Add a layer to the manager.\n\n        Parameters:\n        -----------\n        layer : Layer\n            Layer to add\n        set_active : bool\n            Whether to set this layer as the active layer\n\n        Returns:\n        --------\n        layer : Layer\n            The added layer\n        \"\"\"\n        self.layers[layer.id] = layer\n\n        if set_active:\n            self.active_layer = layer\n\n        return layer\n\n    def get_layer(self, layer_id_or_name):\n        \"\"\"Get a layer by ID or name.\n\n        Parameters:\n        -----------\n        layer_id_or_name : str\n            Layer ID or name\n\n        Returns:\n        --------\n        layer : Layer\n            The requested layer\n        \"\"\"\n        if layer_id_or_name in self.layers:\n            return self.layers[layer_id_or_name]\n\n        for layer in self.layers.values():\n            if layer.name == layer_id_or_name:\n                return layer\n\n        raise ValueError(f\"Layer '{layer_id_or_name}' not found\")\n\n    def get_layer_names(self):\n        \"\"\"Get a list of all layer names.\n\n        Returns:\n        --------\n        names : list\n            List of layer names\n        \"\"\"\n        return [layer.name for layer in self.layers.values()]\n\n    def remove_layer(self, layer_id_or_name):\n        \"\"\"Remove a layer from the manager.\n\n        Parameters:\n        -----------\n        layer_id_or_name : str\n            Layer ID or name\n        \"\"\"\n        layer = self.get_layer(layer_id_or_name)\n\n        if layer.id in self.layers:\n            del self.layers[layer.id]\n\n        if self.active_layer and self.active_layer.id == layer.id:\n            if self.layers:\n                self.active_layer = list(self.layers.values())[-1]\n            else:\n                self.active_layer = None\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the layer manager.</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the layer manager.\"\"\"\n    self.layers = {}\n    self.active_layer = None\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.add_layer","title":"<code>add_layer(layer, set_active=True)</code>","text":"<p>Add a layer to the manager.</p>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.add_layer--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to add set_active : bool     Whether to set this layer as the active layer</p>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.add_layer--returns","title":"Returns:","text":"<p>layer : Layer     The added layer</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def add_layer(self, layer, set_active=True):\n    \"\"\"Add a layer to the manager.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to add\n    set_active : bool\n        Whether to set this layer as the active layer\n\n    Returns:\n    --------\n    layer : Layer\n        The added layer\n    \"\"\"\n    self.layers[layer.id] = layer\n\n    if set_active:\n        self.active_layer = layer\n\n    return layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.get_layer","title":"<code>get_layer(layer_id_or_name)</code>","text":"<p>Get a layer by ID or name.</p>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.get_layer--parameters","title":"Parameters:","text":"<p>layer_id_or_name : str     Layer ID or name</p>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.get_layer--returns","title":"Returns:","text":"<p>layer : Layer     The requested layer</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def get_layer(self, layer_id_or_name):\n    \"\"\"Get a layer by ID or name.\n\n    Parameters:\n    -----------\n    layer_id_or_name : str\n        Layer ID or name\n\n    Returns:\n    --------\n    layer : Layer\n        The requested layer\n    \"\"\"\n    if layer_id_or_name in self.layers:\n        return self.layers[layer_id_or_name]\n\n    for layer in self.layers.values():\n        if layer.name == layer_id_or_name:\n            return layer\n\n    raise ValueError(f\"Layer '{layer_id_or_name}' not found\")\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.get_layer_names","title":"<code>get_layer_names()</code>","text":"<p>Get a list of all layer names.</p>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.get_layer_names--returns","title":"Returns:","text":"<p>names : list     List of layer names</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def get_layer_names(self):\n    \"\"\"Get a list of all layer names.\n\n    Returns:\n    --------\n    names : list\n        List of layer names\n    \"\"\"\n    return [layer.name for layer in self.layers.values()]\n</code></pre>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.remove_layer","title":"<code>remove_layer(layer_id_or_name)</code>","text":"<p>Remove a layer from the manager.</p>"},{"location":"reference/#nickyspatial.core.layer.LayerManager.remove_layer--parameters","title":"Parameters:","text":"<p>layer_id_or_name : str     Layer ID or name</p> Source code in <code>nickyspatial/core/layer.py</code> <pre><code>def remove_layer(self, layer_id_or_name):\n    \"\"\"Remove a layer from the manager.\n\n    Parameters:\n    -----------\n    layer_id_or_name : str\n        Layer ID or name\n    \"\"\"\n    layer = self.get_layer(layer_id_or_name)\n\n    if layer.id in self.layers:\n        del self.layers[layer.id]\n\n    if self.active_layer and self.active_layer.id == layer.id:\n        if self.layers:\n            self.active_layer = list(self.layers.values())[-1]\n        else:\n            self.active_layer = None\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.CommonBase","title":"<code>CommonBase</code>","text":"<p>A shared utility base class for spatial rule sets.</p> <p>This class provides common methods used by multiple rule sets to preprocess layer data and determine spatial relationships between segments.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>class CommonBase:\n    \"\"\"A shared utility base class for spatial rule sets.\n\n    This class provides common methods used by multiple rule sets\n    to preprocess layer data and determine spatial relationships\n    between segments.\n    \"\"\"\n\n    @staticmethod\n    def _preprocess_layer(layer, class_column_name):\n        \"\"\"Prepare geometry and class maps from a spatial layer.\n\n        Parameters:\n        -----------\n        layer : Layer\n            The spatial layer containing objects with segment geometry and class labels.\n        class_column_name : str\n            The column name that stores class values (e.g., \"veg_class\", \"land_use\").\n\n        Returns:\n        --------\n        geom_map : dict\n            A dictionary mapping segment IDs to shapely geometry objects.\n        class_map : dict\n            A dictionary mapping segment IDs to their respective class values.\n        \"\"\"\n        df = layer.objects\n        geom_map = {sid: shape(geom) for sid, geom in zip(df[\"segment_id\"], df[\"geometry\"], strict=False)}\n        class_map = dict(zip(df[\"segment_id\"], df[class_column_name], strict=False))\n        return geom_map, class_map\n\n    @staticmethod\n    def _find_neighbors(segment_id, geom_map):\n        \"\"\"Find neighboring segments based on spatial intersection.\n\n        Parameters:\n        -----------\n        segment_id : int or str\n            The ID of the segment whose neighbors are to be found.\n        geom_map : dict\n            A dictionary mapping segment IDs to shapely geometry objects.\n\n        Returns:\n        --------\n        neighbors : list\n            A list of segment IDs that intersect with the given segment.\n        \"\"\"\n        segment_geom = geom_map[segment_id]\n        neighbors = []\n        for other_id, other_geom in geom_map.items():\n            if other_id != segment_id and segment_geom.intersects(other_geom):\n                neighbors.append(other_id)\n        return neighbors\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.EnclosedByRuleSet","title":"<code>EnclosedByRuleSet</code>","text":"<p>               Bases: <code>CommonBase</code></p> <p>A rule set to reclassify segments based on spatial enclosure.</p> <p>This rule set identifies segments of one class (A) that are entirely surrounded by segments of another class (B), and reclassifies them into a new class.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>class EnclosedByRuleSet(CommonBase):\n    \"\"\"A rule set to reclassify segments based on spatial enclosure.\n\n    This rule set identifies segments of one class (A) that are entirely surrounded\n    by segments of another class (B), and reclassifies them into a new class.\n    \"\"\"\n\n    def __init__(self, name=None):\n        \"\"\"Initialize the merge rule set.\n\n        Parameters:\n        -----------\n        name : str, optional\n            Name of the merge rule set\n        \"\"\"\n        self.name = name if name else \"EnclosedByRuleSet\"\n\n    def execute(\n        self, source_layer, class_column_name, class_value_a, class_value_b, new_class_name, layer_manager=None, layer_name=None\n    ):\n        \"\"\"Apply enclosed-by logic to identify and reclassify segments.\n\n        Parameters:\n        -----------\n        source_layer : Layer\n            The source spatial layer containing segments.\n        class_column_name : str\n            The name of the column containing class labels (e.g., \"veg_class\").\n        class_value_a : str\n            The class value to check for enclosure (target to reclassify).\n        class_value_b : str\n            The class value expected to surround class A segments.\n        new_class_name : str\n            The new class name to assign to enclosed segments.\n        layer_manager : LayerManager, optional\n            Optional manager to register the resulting layer.\n        layer_name : str, optional\n            Optional name for the result layer.\n\n        Returns:\n        --------\n        result_layer : Layer\n            A new layer with updated class values for enclosed segments.\n        \"\"\"\n        if not layer_name:\n            layer_name = f\"{source_layer.name}_{self.name}\"\n\n        result_layer = Layer(name=layer_name, parent=source_layer, type=\"merged\")\n        result_layer.transform = source_layer.transform\n        result_layer.crs = source_layer.crs\n        result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n        df = source_layer.objects.copy()\n        surrounded_segments = []\n        geom_map, class_map = self._preprocess_layer(source_layer, class_column_name)\n\n        for sid in df[\"segment_id\"].unique():\n            if class_map.get(sid) != class_value_a:\n                continue\n\n            neighbors = self._find_neighbors(sid, geom_map)\n            if neighbors and all(class_map.get(n_id) == class_value_b for n_id in neighbors):\n                surrounded_segments.append(sid)\n\n        df.loc[(df[\"segment_id\"].isin(surrounded_segments)), class_column_name] = new_class_name\n\n        result_layer.objects = df\n\n        result_layer.metadata = {\n            \"enclosed_by_ruleset_name\": self.name,\n        }\n\n        if layer_manager:\n            layer_manager.add_layer(result_layer)\n\n        return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.EnclosedByRuleSet.__init__","title":"<code>__init__(name=None)</code>","text":"<p>Initialize the merge rule set.</p>"},{"location":"reference/#nickyspatial.core.rules.EnclosedByRuleSet.__init__--parameters","title":"Parameters:","text":"<p>name : str, optional     Name of the merge rule set</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def __init__(self, name=None):\n    \"\"\"Initialize the merge rule set.\n\n    Parameters:\n    -----------\n    name : str, optional\n        Name of the merge rule set\n    \"\"\"\n    self.name = name if name else \"EnclosedByRuleSet\"\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.EnclosedByRuleSet.execute","title":"<code>execute(source_layer, class_column_name, class_value_a, class_value_b, new_class_name, layer_manager=None, layer_name=None)</code>","text":"<p>Apply enclosed-by logic to identify and reclassify segments.</p>"},{"location":"reference/#nickyspatial.core.rules.EnclosedByRuleSet.execute--parameters","title":"Parameters:","text":"<p>source_layer : Layer     The source spatial layer containing segments. class_column_name : str     The name of the column containing class labels (e.g., \"veg_class\"). class_value_a : str     The class value to check for enclosure (target to reclassify). class_value_b : str     The class value expected to surround class A segments. new_class_name : str     The new class name to assign to enclosed segments. layer_manager : LayerManager, optional     Optional manager to register the resulting layer. layer_name : str, optional     Optional name for the result layer.</p>"},{"location":"reference/#nickyspatial.core.rules.EnclosedByRuleSet.execute--returns","title":"Returns:","text":"<p>result_layer : Layer     A new layer with updated class values for enclosed segments.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def execute(\n    self, source_layer, class_column_name, class_value_a, class_value_b, new_class_name, layer_manager=None, layer_name=None\n):\n    \"\"\"Apply enclosed-by logic to identify and reclassify segments.\n\n    Parameters:\n    -----------\n    source_layer : Layer\n        The source spatial layer containing segments.\n    class_column_name : str\n        The name of the column containing class labels (e.g., \"veg_class\").\n    class_value_a : str\n        The class value to check for enclosure (target to reclassify).\n    class_value_b : str\n        The class value expected to surround class A segments.\n    new_class_name : str\n        The new class name to assign to enclosed segments.\n    layer_manager : LayerManager, optional\n        Optional manager to register the resulting layer.\n    layer_name : str, optional\n        Optional name for the result layer.\n\n    Returns:\n    --------\n    result_layer : Layer\n        A new layer with updated class values for enclosed segments.\n    \"\"\"\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_{self.name}\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"merged\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n    result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n    df = source_layer.objects.copy()\n    surrounded_segments = []\n    geom_map, class_map = self._preprocess_layer(source_layer, class_column_name)\n\n    for sid in df[\"segment_id\"].unique():\n        if class_map.get(sid) != class_value_a:\n            continue\n\n        neighbors = self._find_neighbors(sid, geom_map)\n        if neighbors and all(class_map.get(n_id) == class_value_b for n_id in neighbors):\n            surrounded_segments.append(sid)\n\n    df.loc[(df[\"segment_id\"].isin(surrounded_segments)), class_column_name] = new_class_name\n\n    result_layer.objects = df\n\n    result_layer.metadata = {\n        \"enclosed_by_ruleset_name\": self.name,\n    }\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.MergeRuleSet","title":"<code>MergeRuleSet</code>","text":"<p>               Bases: <code>CommonBase</code></p> <p>A rule set for merging segments of the same class based on specified class values.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>class MergeRuleSet(CommonBase):\n    \"\"\"A rule set for merging segments of the same class based on specified class values.\"\"\"\n\n    def __init__(self, name=None):\n        \"\"\"Initialize the merge rule set.\n\n        Parameters:\n        -----------\n        name : str, optional\n            Name of the merge rule set\n        \"\"\"\n        self.name = name if name else \"MergeRuleSet\"\n\n    def execute(self, source_layer, class_column_name, class_value, layer_manager=None, layer_name=None):\n        \"\"\"Merge segments of the same class in a layer.\n\n        Parameters:\n        -----------\n        source_layer : Layer\n            Source layer with segments to merge\n        class_value : str or list of str\n            One or more attribute field names to group and merge segments\n        layer_manager : LayerManager, optional\n            Layer manager to add the result layer to\n        layer_name : str, optional\n            Name for the result layer\n\n        Returns:\n        --------\n        result_layer : Layer\n            Layer with merged geometries\n        \"\"\"\n        if not layer_name:\n            layer_name = f\"{source_layer.name}_{self.name}\"\n\n        result_layer = Layer(name=layer_name, parent=source_layer, type=\"merged\")\n        result_layer.transform = source_layer.transform\n        result_layer.crs = source_layer.crs\n        result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n        df = source_layer.objects.copy()\n\n        # Handle single or multiple class fields\n        if isinstance(class_value, str):\n            class_values = [class_value]\n        else:\n            class_values = class_value\n\n        new_rows = []\n        to_drop = set()\n        geom_map, class_map = self._preprocess_layer(source_layer, class_column_name)\n\n        for class_value in class_values:\n            visited = set()\n\n            for sid in df[\"segment_id\"].unique():\n                if sid in visited or class_map[sid] != class_value:\n                    continue\n\n                group_geom = [geom_map[sid]]\n                group_ids = [sid]\n                queue = [sid]\n                visited.add(sid)\n\n                while queue:\n                    current_id = queue.pop()\n                    neighbors = self._find_neighbors(current_id, geom_map)\n                    for n_id in neighbors:\n                        if n_id not in visited and class_map.get(n_id) == class_value:\n                            visited.add(n_id)\n                            group_geom.append(geom_map[n_id])\n                            group_ids.append(n_id)\n                            queue.append(n_id)\n\n                merged_geom = unary_union(group_geom)\n                row_data = {\"segment_id\": min(group_ids), class_column_name: class_value, \"geometry\": merged_geom}\n\n                new_rows.append(row_data)\n                to_drop.update(group_ids)\n\n        df = df[~df[\"segment_id\"].isin(to_drop)]\n        df = pd.concat([df, pd.DataFrame(new_rows)], ignore_index=True)\n        result_layer.objects = df\n\n        result_layer.metadata = {\n            \"mergeruleset_name\": self.name,\n            \"merged_fields\": class_values,\n        }\n\n        if layer_manager:\n            layer_manager.add_layer(result_layer)\n\n        return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.MergeRuleSet.__init__","title":"<code>__init__(name=None)</code>","text":"<p>Initialize the merge rule set.</p>"},{"location":"reference/#nickyspatial.core.rules.MergeRuleSet.__init__--parameters","title":"Parameters:","text":"<p>name : str, optional     Name of the merge rule set</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def __init__(self, name=None):\n    \"\"\"Initialize the merge rule set.\n\n    Parameters:\n    -----------\n    name : str, optional\n        Name of the merge rule set\n    \"\"\"\n    self.name = name if name else \"MergeRuleSet\"\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.MergeRuleSet.execute","title":"<code>execute(source_layer, class_column_name, class_value, layer_manager=None, layer_name=None)</code>","text":"<p>Merge segments of the same class in a layer.</p>"},{"location":"reference/#nickyspatial.core.rules.MergeRuleSet.execute--parameters","title":"Parameters:","text":"<p>source_layer : Layer     Source layer with segments to merge class_value : str or list of str     One or more attribute field names to group and merge segments layer_manager : LayerManager, optional     Layer manager to add the result layer to layer_name : str, optional     Name for the result layer</p>"},{"location":"reference/#nickyspatial.core.rules.MergeRuleSet.execute--returns","title":"Returns:","text":"<p>result_layer : Layer     Layer with merged geometries</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def execute(self, source_layer, class_column_name, class_value, layer_manager=None, layer_name=None):\n    \"\"\"Merge segments of the same class in a layer.\n\n    Parameters:\n    -----------\n    source_layer : Layer\n        Source layer with segments to merge\n    class_value : str or list of str\n        One or more attribute field names to group and merge segments\n    layer_manager : LayerManager, optional\n        Layer manager to add the result layer to\n    layer_name : str, optional\n        Name for the result layer\n\n    Returns:\n    --------\n    result_layer : Layer\n        Layer with merged geometries\n    \"\"\"\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_{self.name}\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"merged\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n    result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n    df = source_layer.objects.copy()\n\n    # Handle single or multiple class fields\n    if isinstance(class_value, str):\n        class_values = [class_value]\n    else:\n        class_values = class_value\n\n    new_rows = []\n    to_drop = set()\n    geom_map, class_map = self._preprocess_layer(source_layer, class_column_name)\n\n    for class_value in class_values:\n        visited = set()\n\n        for sid in df[\"segment_id\"].unique():\n            if sid in visited or class_map[sid] != class_value:\n                continue\n\n            group_geom = [geom_map[sid]]\n            group_ids = [sid]\n            queue = [sid]\n            visited.add(sid)\n\n            while queue:\n                current_id = queue.pop()\n                neighbors = self._find_neighbors(current_id, geom_map)\n                for n_id in neighbors:\n                    if n_id not in visited and class_map.get(n_id) == class_value:\n                        visited.add(n_id)\n                        group_geom.append(geom_map[n_id])\n                        group_ids.append(n_id)\n                        queue.append(n_id)\n\n            merged_geom = unary_union(group_geom)\n            row_data = {\"segment_id\": min(group_ids), class_column_name: class_value, \"geometry\": merged_geom}\n\n            new_rows.append(row_data)\n            to_drop.update(group_ids)\n\n    df = df[~df[\"segment_id\"].isin(to_drop)]\n    df = pd.concat([df, pd.DataFrame(new_rows)], ignore_index=True)\n    result_layer.objects = df\n\n    result_layer.metadata = {\n        \"mergeruleset_name\": self.name,\n        \"merged_fields\": class_values,\n    }\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.Rule","title":"<code>Rule</code>","text":"<p>A rule defines a condition to classify segments.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>class Rule:\n    \"\"\"A rule defines a condition to classify segments.\"\"\"\n\n    def __init__(self, name, condition, class_value=None):\n        \"\"\"Initialize a rule.\n\n        Parameters:\n        -----------\n        name : str\n            Name of the rule\n        condition : str\n            Condition as a string expression that can be evaluated using numexpr\n        class_value : str, optional\n            Value to assign when the condition is met.\n            If None, uses the rule name.\n        \"\"\"\n        self.name = name\n        self.condition = condition\n        self.class_value = class_value if class_value is not None else name\n\n    def __str__(self):\n        \"\"\"String representation of the rule.\"\"\"\n        return f\"Rule '{self.name}': {self.condition} -&gt; {self.class_value}\"\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.Rule.__init__","title":"<code>__init__(name, condition, class_value=None)</code>","text":"<p>Initialize a rule.</p>"},{"location":"reference/#nickyspatial.core.rules.Rule.__init__--parameters","title":"Parameters:","text":"<p>name : str     Name of the rule condition : str     Condition as a string expression that can be evaluated using numexpr class_value : str, optional     Value to assign when the condition is met.     If None, uses the rule name.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def __init__(self, name, condition, class_value=None):\n    \"\"\"Initialize a rule.\n\n    Parameters:\n    -----------\n    name : str\n        Name of the rule\n    condition : str\n        Condition as a string expression that can be evaluated using numexpr\n    class_value : str, optional\n        Value to assign when the condition is met.\n        If None, uses the rule name.\n    \"\"\"\n    self.name = name\n    self.condition = condition\n    self.class_value = class_value if class_value is not None else name\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.Rule.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the rule.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def __str__(self):\n    \"\"\"String representation of the rule.\"\"\"\n    return f\"Rule '{self.name}': {self.condition} -&gt; {self.class_value}\"\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.RuleSet","title":"<code>RuleSet</code>","text":"<p>A collection of rules to apply to a layer.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>class RuleSet:\n    \"\"\"A collection of rules to apply to a layer.\"\"\"\n\n    def __init__(self, name=None):\n        \"\"\"Initialize a rule set.\n\n        Parameters:\n        -----------\n        name : str, optional\n            Name of the rule set\n        \"\"\"\n        self.name = name if name else \"RuleSet\"\n        self.rules = []\n\n    @staticmethod\n    def wrap_condition_parts_simple(self, condition):\n        \"\"\"Wrap condition parts with parentheses for evaluation.\"\"\"\n        parts = condition.split(\"&amp;\")\n        parts = [f\"({part.strip()})\" for part in parts]\n        return \" &amp; \".join(parts)\n\n    def add_rule(self, name, condition, class_value=None):\n        \"\"\"Add a rule to the rule set.\n\n        Parameters:\n        -----------\n        name : str\n            Name of the rule\n        condition : str\n            Condition as a string expression that can be evaluated using numexpr\n        class_value : str, optional\n            Value to assign when the condition is met\n\n        Returns:\n        --------\n        rule : Rule\n            The added rule\n        \"\"\"\n        rule = Rule(name, condition, class_value)\n        self.rules.append(rule)\n        return rule\n\n    def get_rules(self):\n        \"\"\"Get the list of rules in the rule set.\n\n        Returns:\n        --------\n        list of tuples\n            List of (name, condition) tuples for each rule\n        \"\"\"\n        return [(rule.name, rule.condition) for rule in self.rules]\n\n    def execute(\n        self,\n        source_layer,\n        layer_manager=None,\n        layer_name=None,\n        result_field=\"classification\",\n    ):\n        \"\"\"Apply rules to classify segments in a layer.\n\n        Parameters:\n        -----------\n        source_layer : Layer\n            Source layer with segments to classify\n        layer_manager : LayerManager, optional\n            Layer manager to add the result layer to\n        layer_name : str, optional\n            Name for the result layer\n        result_field : str\n            Field name to store classification results\n\n        Returns:\n        --------\n        result_layer : Layer\n            Layer with classification results\n        \"\"\"\n        if not layer_name:\n            layer_name = f\"{source_layer.name}_{self.name}\"\n\n        result_layer = Layer(name=layer_name, parent=source_layer, type=\"classification\")\n        result_layer.transform = source_layer.transform\n        result_layer.crs = source_layer.crs\n        result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n        result_layer.objects = source_layer.objects.copy()\n\n        if result_field not in result_layer.objects.columns:\n            result_layer.objects[result_field] = None\n\n        result_layer.metadata = {\n            \"ruleset_name\": self.name,\n            \"rules\": [\n                {\n                    \"name\": rule.name,\n                    \"condition\": rule.condition,\n                    \"class_value\": rule.class_value,\n                }\n                for rule in self.rules\n            ],\n            \"result_field\": result_field,\n        }\n\n        for rule in self.rules:\n            try:\n                if result_field in result_layer.objects.columns and (\n                    f\"{result_field} ==\" in rule.condition\n                    or f\"{result_field}==\" in rule.condition\n                    or f\"{result_field} !=\" in rule.condition\n                    or f\"{result_field}!=\" in rule.condition\n                ):\n                    ## TODO : better way to handle this , because &amp; searching in string is not a good idea,\n                    # this might produce bug for complex rules\n                    eval_condition = rule.condition.replace(\"&amp;\", \" and \").replace(\"|\", \" or \")\n\n                    mask = result_layer.objects.apply(\n                        lambda row, cond=eval_condition: eval(\n                            cond,\n                            {\"__builtins__\": {}},\n                            {col: row[col] for col in result_layer.objects.columns if col != \"geometry\"},\n                        ),\n                        axis=1,\n                    )\n\n                else:\n                    try:\n                        local_dict = {\n                            col: result_layer.objects[col].values for col in result_layer.objects.columns if col != \"geometry\"\n                        }\n\n                        mask = ne.evaluate(rule.condition, local_dict=local_dict)\n                        mask = pd.Series(mask, index=result_layer.objects.index).fillna(False)\n                    except Exception:\n                        mask = result_layer.objects.eval(rule.condition, engine=\"python\")\n\n                result_layer.objects.loc[mask, result_field] = rule.class_value\n\n            except Exception as e:\n                print(f\"Error applying rule '{rule.name}': {str(e)}\")\n                continue\n\n        if layer_manager:\n            layer_manager.add_layer(result_layer)\n\n        return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.__init__","title":"<code>__init__(name=None)</code>","text":"<p>Initialize a rule set.</p>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.__init__--parameters","title":"Parameters:","text":"<p>name : str, optional     Name of the rule set</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def __init__(self, name=None):\n    \"\"\"Initialize a rule set.\n\n    Parameters:\n    -----------\n    name : str, optional\n        Name of the rule set\n    \"\"\"\n    self.name = name if name else \"RuleSet\"\n    self.rules = []\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.add_rule","title":"<code>add_rule(name, condition, class_value=None)</code>","text":"<p>Add a rule to the rule set.</p>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.add_rule--parameters","title":"Parameters:","text":"<p>name : str     Name of the rule condition : str     Condition as a string expression that can be evaluated using numexpr class_value : str, optional     Value to assign when the condition is met</p>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.add_rule--returns","title":"Returns:","text":"<p>rule : Rule     The added rule</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def add_rule(self, name, condition, class_value=None):\n    \"\"\"Add a rule to the rule set.\n\n    Parameters:\n    -----------\n    name : str\n        Name of the rule\n    condition : str\n        Condition as a string expression that can be evaluated using numexpr\n    class_value : str, optional\n        Value to assign when the condition is met\n\n    Returns:\n    --------\n    rule : Rule\n        The added rule\n    \"\"\"\n    rule = Rule(name, condition, class_value)\n    self.rules.append(rule)\n    return rule\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.execute","title":"<code>execute(source_layer, layer_manager=None, layer_name=None, result_field='classification')</code>","text":"<p>Apply rules to classify segments in a layer.</p>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.execute--parameters","title":"Parameters:","text":"<p>source_layer : Layer     Source layer with segments to classify layer_manager : LayerManager, optional     Layer manager to add the result layer to layer_name : str, optional     Name for the result layer result_field : str     Field name to store classification results</p>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.execute--returns","title":"Returns:","text":"<p>result_layer : Layer     Layer with classification results</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def execute(\n    self,\n    source_layer,\n    layer_manager=None,\n    layer_name=None,\n    result_field=\"classification\",\n):\n    \"\"\"Apply rules to classify segments in a layer.\n\n    Parameters:\n    -----------\n    source_layer : Layer\n        Source layer with segments to classify\n    layer_manager : LayerManager, optional\n        Layer manager to add the result layer to\n    layer_name : str, optional\n        Name for the result layer\n    result_field : str\n        Field name to store classification results\n\n    Returns:\n    --------\n    result_layer : Layer\n        Layer with classification results\n    \"\"\"\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_{self.name}\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"classification\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n    result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n    result_layer.objects = source_layer.objects.copy()\n\n    if result_field not in result_layer.objects.columns:\n        result_layer.objects[result_field] = None\n\n    result_layer.metadata = {\n        \"ruleset_name\": self.name,\n        \"rules\": [\n            {\n                \"name\": rule.name,\n                \"condition\": rule.condition,\n                \"class_value\": rule.class_value,\n            }\n            for rule in self.rules\n        ],\n        \"result_field\": result_field,\n    }\n\n    for rule in self.rules:\n        try:\n            if result_field in result_layer.objects.columns and (\n                f\"{result_field} ==\" in rule.condition\n                or f\"{result_field}==\" in rule.condition\n                or f\"{result_field} !=\" in rule.condition\n                or f\"{result_field}!=\" in rule.condition\n            ):\n                ## TODO : better way to handle this , because &amp; searching in string is not a good idea,\n                # this might produce bug for complex rules\n                eval_condition = rule.condition.replace(\"&amp;\", \" and \").replace(\"|\", \" or \")\n\n                mask = result_layer.objects.apply(\n                    lambda row, cond=eval_condition: eval(\n                        cond,\n                        {\"__builtins__\": {}},\n                        {col: row[col] for col in result_layer.objects.columns if col != \"geometry\"},\n                    ),\n                    axis=1,\n                )\n\n            else:\n                try:\n                    local_dict = {\n                        col: result_layer.objects[col].values for col in result_layer.objects.columns if col != \"geometry\"\n                    }\n\n                    mask = ne.evaluate(rule.condition, local_dict=local_dict)\n                    mask = pd.Series(mask, index=result_layer.objects.index).fillna(False)\n                except Exception:\n                    mask = result_layer.objects.eval(rule.condition, engine=\"python\")\n\n            result_layer.objects.loc[mask, result_field] = rule.class_value\n\n        except Exception as e:\n            print(f\"Error applying rule '{rule.name}': {str(e)}\")\n            continue\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.get_rules","title":"<code>get_rules()</code>","text":"<p>Get the list of rules in the rule set.</p>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.get_rules--returns","title":"Returns:","text":"<p>list of tuples     List of (name, condition) tuples for each rule</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def get_rules(self):\n    \"\"\"Get the list of rules in the rule set.\n\n    Returns:\n    --------\n    list of tuples\n        List of (name, condition) tuples for each rule\n    \"\"\"\n    return [(rule.name, rule.condition) for rule in self.rules]\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.RuleSet.wrap_condition_parts_simple","title":"<code>wrap_condition_parts_simple(condition)</code>  <code>staticmethod</code>","text":"<p>Wrap condition parts with parentheses for evaluation.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>@staticmethod\ndef wrap_condition_parts_simple(self, condition):\n    \"\"\"Wrap condition parts with parentheses for evaluation.\"\"\"\n    parts = condition.split(\"&amp;\")\n    parts = [f\"({part.strip()})\" for part in parts]\n    return \" &amp; \".join(parts)\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.TouchedByRuleSet","title":"<code>TouchedByRuleSet</code>","text":"<p>               Bases: <code>CommonBase</code></p> <p>A rule set to reclassify segments based on spatial enclosure.</p> <p>This rule set identifies segments of one class (A) that are entirely surrounded by segments of another class (B), and reclassifies them into a new class.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>class TouchedByRuleSet(CommonBase):\n    \"\"\"A rule set to reclassify segments based on spatial enclosure.\n\n    This rule set identifies segments of one class (A) that are entirely surrounded\n    by segments of another class (B), and reclassifies them into a new class.\n    \"\"\"\n\n    def __init__(self, name=None):\n        \"\"\"Initialize the merge rule set.\n\n        Parameters:\n        -----------\n        name : str, optional\n            Name of the merge rule set\n        \"\"\"\n        self.name = name if name else \"TouchedByRuleSet\"\n\n    def execute(\n        self, source_layer, class_column_name, class_value_a, class_value_b, new_class_name, layer_manager=None, layer_name=None\n    ):\n        \"\"\"Executes the merge rule set by identifying and updating segments of a given class that are adjacent to another class!\n\n        Parameters:\n        - source_layer: Layer\n            The input layer containing segment geometries and attributes.\n        - class_column_name: str\n            The name of the column containing class labels.\n        - class_value_a: str or int\n            The class value of segments to be checked for touching neighbors.\n        - class_value_b: str or int\n            The class value of neighboring segments that would trigger a merge.\n        - new_class_name: str\n            The new class value to assign to segments of class_value_a that touch class_value_b.\n        - layer_manager: optional\n            An optional manager for adding the resulting layer to a collection or interface.\n        - layer_name: optional\n            Optional custom name for the resulting layer. Defaults to \"&lt;source_layer_name&gt;_&lt;ruleset_name&gt;\".\n\n        Returns:\n        - result_layer: Layer\n            A new Layer object with updated segment classifications where applicable.\n\n        Logic:\n        - Copies the source layer and initializes a new result layer.\n        - Preprocesses the source layer to build geometry and class lookup maps.\n        - Iterates through each segment of class_value_a, checking if any of its neighbors belong to class_value_b.\n        - If so, updates the segment's class to new_class_name.\n        - Stores the modified DataFrame in the result layer and optionally registers it via the layer_manager.\n\n        \"\"\"\n        if not layer_name:\n            layer_name = f\"{source_layer.name}_{self.name}\"\n\n        result_layer = Layer(name=layer_name, parent=source_layer, type=\"merged\")\n        result_layer.transform = source_layer.transform\n        result_layer.crs = source_layer.crs\n        result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n        df = source_layer.objects.copy()\n        touched_segments = []\n        geom_map, class_map = self._preprocess_layer(source_layer, class_column_name)\n\n        for sid in df[\"segment_id\"].unique():\n            if class_map.get(sid) != class_value_a:\n                continue\n\n            neighbors = self._find_neighbors(sid, geom_map)\n            if neighbors and any(class_map.get(n_id) == class_value_b for n_id in neighbors):\n                touched_segments.append(sid)\n\n        df.loc[(df[\"segment_id\"].isin(touched_segments)), class_column_name] = new_class_name\n\n        result_layer.objects = df\n\n        result_layer.metadata = {\n            \"enclosed_by_ruleset_name\": self.name,\n        }\n\n        if layer_manager:\n            layer_manager.add_layer(result_layer)\n\n        return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.TouchedByRuleSet.__init__","title":"<code>__init__(name=None)</code>","text":"<p>Initialize the merge rule set.</p>"},{"location":"reference/#nickyspatial.core.rules.TouchedByRuleSet.__init__--parameters","title":"Parameters:","text":"<p>name : str, optional     Name of the merge rule set</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def __init__(self, name=None):\n    \"\"\"Initialize the merge rule set.\n\n    Parameters:\n    -----------\n    name : str, optional\n        Name of the merge rule set\n    \"\"\"\n    self.name = name if name else \"TouchedByRuleSet\"\n</code></pre>"},{"location":"reference/#nickyspatial.core.rules.TouchedByRuleSet.execute","title":"<code>execute(source_layer, class_column_name, class_value_a, class_value_b, new_class_name, layer_manager=None, layer_name=None)</code>","text":"<p>Executes the merge rule set by identifying and updating segments of a given class that are adjacent to another class!</p> <ul> <li>source_layer: Layer     The input layer containing segment geometries and attributes.</li> <li>class_column_name: str     The name of the column containing class labels.</li> <li>class_value_a: str or int     The class value of segments to be checked for touching neighbors.</li> <li>class_value_b: str or int     The class value of neighboring segments that would trigger a merge.</li> <li>new_class_name: str     The new class value to assign to segments of class_value_a that touch class_value_b.</li> <li>layer_manager: optional     An optional manager for adding the resulting layer to a collection or interface.</li> <li>layer_name: optional     Optional custom name for the resulting layer. Defaults to \"_\". <ul> <li>result_layer: Layer     A new Layer object with updated segment classifications where applicable.</li> </ul> <p>Logic: - Copies the source layer and initializes a new result layer. - Preprocesses the source layer to build geometry and class lookup maps. - Iterates through each segment of class_value_a, checking if any of its neighbors belong to class_value_b. - If so, updates the segment's class to new_class_name. - Stores the modified DataFrame in the result layer and optionally registers it via the layer_manager.</p> Source code in <code>nickyspatial/core/rules.py</code> <pre><code>def execute(\n    self, source_layer, class_column_name, class_value_a, class_value_b, new_class_name, layer_manager=None, layer_name=None\n):\n    \"\"\"Executes the merge rule set by identifying and updating segments of a given class that are adjacent to another class!\n\n    Parameters:\n    - source_layer: Layer\n        The input layer containing segment geometries and attributes.\n    - class_column_name: str\n        The name of the column containing class labels.\n    - class_value_a: str or int\n        The class value of segments to be checked for touching neighbors.\n    - class_value_b: str or int\n        The class value of neighboring segments that would trigger a merge.\n    - new_class_name: str\n        The new class value to assign to segments of class_value_a that touch class_value_b.\n    - layer_manager: optional\n        An optional manager for adding the resulting layer to a collection or interface.\n    - layer_name: optional\n        Optional custom name for the resulting layer. Defaults to \"&lt;source_layer_name&gt;_&lt;ruleset_name&gt;\".\n\n    Returns:\n    - result_layer: Layer\n        A new Layer object with updated segment classifications where applicable.\n\n    Logic:\n    - Copies the source layer and initializes a new result layer.\n    - Preprocesses the source layer to build geometry and class lookup maps.\n    - Iterates through each segment of class_value_a, checking if any of its neighbors belong to class_value_b.\n    - If so, updates the segment's class to new_class_name.\n    - Stores the modified DataFrame in the result layer and optionally registers it via the layer_manager.\n\n    \"\"\"\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_{self.name}\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"merged\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n    result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n    df = source_layer.objects.copy()\n    touched_segments = []\n    geom_map, class_map = self._preprocess_layer(source_layer, class_column_name)\n\n    for sid in df[\"segment_id\"].unique():\n        if class_map.get(sid) != class_value_a:\n            continue\n\n        neighbors = self._find_neighbors(sid, geom_map)\n        if neighbors and any(class_map.get(n_id) == class_value_b for n_id in neighbors):\n            touched_segments.append(sid)\n\n    df.loc[(df[\"segment_id\"].isin(touched_segments)), class_column_name] = new_class_name\n\n    result_layer.objects = df\n\n    result_layer.metadata = {\n        \"enclosed_by_ruleset_name\": self.name,\n    }\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre> <p>Implements segmentation algorithms to partition images into meaningful region objects.</p> <p>The functions here might apply clustering or region-growing techniques, aiding object-based remote sensing analysis. This module includes the SlicSegmentation class, which implements a bottom-up region-growing algorithm</p>"},{"location":"reference/#nickyspatial.core.segmentation.SlicSegmentation","title":"<code>SlicSegmentation</code>","text":"<p>Implementation of Multiresolution segmentation algorithm.</p> <p>This algorithm segments an image using a bottom-up region-growing approach that optimizes the homogeneity of pixel values within segments while considering shape compactness.</p> Source code in <code>nickyspatial/core/segmentation.py</code> <pre><code>class SlicSegmentation:\n    \"\"\"Implementation of Multiresolution segmentation algorithm.\n\n    This algorithm segments an image using a bottom-up region-growing approach\n    that optimizes the homogeneity of pixel values within segments while\n    considering shape compactness.\n    \"\"\"\n\n    def __init__(self, scale=15, compactness=0.6):\n        \"\"\"Initialize the segmentation algorithm.\n\n        Parameters:\n        -----------\n        scale : float\n            Scale parameter that influences the size of the segments.\n            Higher values create larger segments.\n        shape : float, range [0, 1]\n            Weight of shape criterion vs. color criterion.\n            Higher values give more weight to shape.\n        compactness : float, range [0, 1]\n            Weight of compactness criterion vs. smoothness criterion.\n            Higher values create more compact segments.\n        \"\"\"\n        self.scale = scale\n        self.compactness = compactness\n\n    def execute(self, image_data, transform, crs, layer_manager=None, layer_name=None):\n        \"\"\"Perform segmentation and create a layer with the results.\n\n        Parameters:\n        -----------\n        image_data : numpy.ndarray\n            Array with raster data values (bands, height, width)\n        transform : affine.Affine\n            Affine transformation for the raster\n        crs : rasterio.crs.CRS\n            Coordinate reference system\n        layer_manager : LayerManager, optional\n            Layer manager to add the result layer to\n        layer_name : str, optional\n            Name for the result layer\n\n        Returns:\n        --------\n        layer : Layer\n            Layer containing the segmentation results\n        \"\"\"\n        num_bands, height, width = image_data.shape\n\n        normalized_bands = []\n        for i in range(num_bands):\n            band = image_data[i]\n\n            if band.max() == band.min():\n                normalized_bands.append(np.zeros_like(band))\n                continue\n\n            norm_band = (band - band.min()) / (band.max() - band.min())\n            normalized_bands.append(norm_band)\n\n        multichannel_image = np.stack(normalized_bands, axis=-1)\n\n        n_segments = int(width * height / (self.scale * self.scale))\n        print(f\"Number of segments: {n_segments}\")\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            segments = segmentation.slic(\n                multichannel_image,\n                n_segments=n_segments,\n                compactness=self.compactness,\n                sigma=1.0,\n                start_label=1,\n                channel_axis=-1,\n            )\n\n        if not layer_name:\n            layer_name = f\"Segmentation_scale{self.scale}_comp{self.compactness}\"\n\n        layer = Layer(name=layer_name, type=\"segmentation\")\n        layer.raster = segments\n        layer.transform = transform\n        layer.crs = crs\n        layer.metadata = {\n            \"scale\": self.scale,\n            \"compactness\": self.compactness,\n            \"n_segments\": n_segments,\n            \"num_segments_actual\": len(np.unique(segments)),\n        }\n\n        segment_objects = self._create_segment_objects(segments, transform, crs)\n        layer.objects = segment_objects\n\n        bands = [f\"band_{i + 1}\" for i in range(num_bands)]\n        self._calculate_statistics(layer, image_data, bands)\n\n        if layer_manager:\n            layer_manager.add_layer(layer)\n\n        return layer\n\n    def _create_segment_objects(self, segments, transform, crs):\n        \"\"\"Create vector objects from segments.\n\n        Parameters:\n        -----------\n        segments : numpy.ndarray\n            Array with segment IDs\n        transform : affine.Affine\n            Affine transformation for the raster\n        crs : rasterio.crs.CRS\n            Coordinate reference system\n\n        Returns:\n        --------\n        segment_objects : geopandas.GeoDataFrame\n            GeoDataFrame with segment polygons\n        \"\"\"\n        segment_ids = np.unique(segments)\n\n        geometries = []\n        properties = []\n\n        for segment_id in segment_ids:\n            mask = segments == segment_id\n\n            if not np.any(mask):\n                continue\n\n            shapes = rasterio.features.shapes(mask.astype(np.int16), mask=mask, transform=transform)\n\n            segment_polygons = []\n            for geom, val in shapes:\n                if val == 1:\n                    try:\n                        polygon = Polygon(geom[\"coordinates\"][0])\n                        if polygon.is_valid:\n                            segment_polygons.append(polygon)\n                    except Exception:\n                        continue\n\n            if not segment_polygons:\n                continue\n\n            largest_polygon = max(segment_polygons, key=lambda p: p.area)\n\n            area_pixels = np.sum(mask)\n\n            pixel_width = abs(transform.a)\n            pixel_height = abs(transform.e)\n            area_units = area_pixels * pixel_width * pixel_height\n\n            prop = {\n                \"segment_id\": int(segment_id),\n                \"area_pixels\": int(area_pixels),\n                \"area_units\": float(area_units),\n            }\n\n            geometries.append(largest_polygon)\n            properties.append(prop)\n\n        gdf = gpd.GeoDataFrame(properties, geometry=geometries, crs=crs)\n        return gdf\n\n    def _calculate_statistics(self, layer, image_data, bands):\n        \"\"\"Calculate statistics for segments based on image data.\n\n        Parameters:\n        -----------\n        layer : Layer\n            Layer containing segments\n        image_data : numpy.ndarray\n            Array with raster data values (bands, height, width)\n        bands : list of str\n            Names of the bands\n        \"\"\"\n        segments = layer.raster\n        segment_objects = layer.objects\n\n        segment_ids = segment_objects[\"segment_id\"].values\n\n        for i, band_name in enumerate(bands):\n            if i &gt;= image_data.shape[0]:\n                break\n\n            band_data = image_data[i]\n\n            for segment_id in segment_ids:\n                mask = segments == segment_id\n\n                if segment_id not in segment_objects[\"segment_id\"].values:\n                    continue\n\n                segment_pixels = band_data[mask]\n\n                if len(segment_pixels) == 0:\n                    continue\n\n                mean_val = float(np.mean(segment_pixels))\n                std_val = float(np.std(segment_pixels))\n                min_val = float(np.min(segment_pixels))\n                max_val = float(np.max(segment_pixels))\n                median_val = float(np.median(segment_pixels))\n\n                idx = segment_objects.index[segment_objects[\"segment_id\"] == segment_id].tolist()[0]\n                segment_objects.at[idx, f\"{band_name}_mean\"] = mean_val\n                segment_objects.at[idx, f\"{band_name}_std\"] = std_val\n                segment_objects.at[idx, f\"{band_name}_min\"] = min_val\n                segment_objects.at[idx, f\"{band_name}_max\"] = max_val\n                segment_objects.at[idx, f\"{band_name}_median\"] = median_val\n</code></pre>"},{"location":"reference/#nickyspatial.core.segmentation.SlicSegmentation.__init__","title":"<code>__init__(scale=15, compactness=0.6)</code>","text":"<p>Initialize the segmentation algorithm.</p>"},{"location":"reference/#nickyspatial.core.segmentation.SlicSegmentation.__init__--parameters","title":"Parameters:","text":"<p>scale : float     Scale parameter that influences the size of the segments.     Higher values create larger segments. shape : float, range [0, 1]     Weight of shape criterion vs. color criterion.     Higher values give more weight to shape. compactness : float, range [0, 1]     Weight of compactness criterion vs. smoothness criterion.     Higher values create more compact segments.</p> Source code in <code>nickyspatial/core/segmentation.py</code> <pre><code>def __init__(self, scale=15, compactness=0.6):\n    \"\"\"Initialize the segmentation algorithm.\n\n    Parameters:\n    -----------\n    scale : float\n        Scale parameter that influences the size of the segments.\n        Higher values create larger segments.\n    shape : float, range [0, 1]\n        Weight of shape criterion vs. color criterion.\n        Higher values give more weight to shape.\n    compactness : float, range [0, 1]\n        Weight of compactness criterion vs. smoothness criterion.\n        Higher values create more compact segments.\n    \"\"\"\n    self.scale = scale\n    self.compactness = compactness\n</code></pre>"},{"location":"reference/#nickyspatial.core.segmentation.SlicSegmentation.execute","title":"<code>execute(image_data, transform, crs, layer_manager=None, layer_name=None)</code>","text":"<p>Perform segmentation and create a layer with the results.</p>"},{"location":"reference/#nickyspatial.core.segmentation.SlicSegmentation.execute--parameters","title":"Parameters:","text":"<p>image_data : numpy.ndarray     Array with raster data values (bands, height, width) transform : affine.Affine     Affine transformation for the raster crs : rasterio.crs.CRS     Coordinate reference system layer_manager : LayerManager, optional     Layer manager to add the result layer to layer_name : str, optional     Name for the result layer</p>"},{"location":"reference/#nickyspatial.core.segmentation.SlicSegmentation.execute--returns","title":"Returns:","text":"<p>layer : Layer     Layer containing the segmentation results</p> Source code in <code>nickyspatial/core/segmentation.py</code> <pre><code>def execute(self, image_data, transform, crs, layer_manager=None, layer_name=None):\n    \"\"\"Perform segmentation and create a layer with the results.\n\n    Parameters:\n    -----------\n    image_data : numpy.ndarray\n        Array with raster data values (bands, height, width)\n    transform : affine.Affine\n        Affine transformation for the raster\n    crs : rasterio.crs.CRS\n        Coordinate reference system\n    layer_manager : LayerManager, optional\n        Layer manager to add the result layer to\n    layer_name : str, optional\n        Name for the result layer\n\n    Returns:\n    --------\n    layer : Layer\n        Layer containing the segmentation results\n    \"\"\"\n    num_bands, height, width = image_data.shape\n\n    normalized_bands = []\n    for i in range(num_bands):\n        band = image_data[i]\n\n        if band.max() == band.min():\n            normalized_bands.append(np.zeros_like(band))\n            continue\n\n        norm_band = (band - band.min()) / (band.max() - band.min())\n        normalized_bands.append(norm_band)\n\n    multichannel_image = np.stack(normalized_bands, axis=-1)\n\n    n_segments = int(width * height / (self.scale * self.scale))\n    print(f\"Number of segments: {n_segments}\")\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        segments = segmentation.slic(\n            multichannel_image,\n            n_segments=n_segments,\n            compactness=self.compactness,\n            sigma=1.0,\n            start_label=1,\n            channel_axis=-1,\n        )\n\n    if not layer_name:\n        layer_name = f\"Segmentation_scale{self.scale}_comp{self.compactness}\"\n\n    layer = Layer(name=layer_name, type=\"segmentation\")\n    layer.raster = segments\n    layer.transform = transform\n    layer.crs = crs\n    layer.metadata = {\n        \"scale\": self.scale,\n        \"compactness\": self.compactness,\n        \"n_segments\": n_segments,\n        \"num_segments_actual\": len(np.unique(segments)),\n    }\n\n    segment_objects = self._create_segment_objects(segments, transform, crs)\n    layer.objects = segment_objects\n\n    bands = [f\"band_{i + 1}\" for i in range(num_bands)]\n    self._calculate_statistics(layer, image_data, bands)\n\n    if layer_manager:\n        layer_manager.add_layer(layer)\n\n    return layer\n</code></pre>"},{"location":"reference/#nickyspatialfilters","title":"<code>nickyspatial.filters</code>","text":"<p>The filters package provides modules for applying transformations to raster data.</p> <p>It includes spatial filters (e.g., smoothing) as well as spectral filters (e.g., band math). Main idea is to further manipulate the objects such as merging segments or applying pre-defined rules to filter objects based on their attributes.</p> <p>Implements spatial operations like smoothing and morphological transformations.</p> <p>These filters can modify the geometry or arrangement of pixel values to enhance or simplify data for object analysis. The functions here include smoothing boundaries, merging small segments, and selecting segments based on area. These operations are essential for preparing data for object-based image analysis, especially in remote sensing applications. The functions are designed to work with raster data and can be applied to layers created from segmentation algorithms.</p> <p>Performs spectral-based manipulations of imagery, including band arithmetic and transformations.</p> <p>It supports generating new spectral bands or combinations to highlight specific features. It also includes functions for enhancing contrast and applying spectral filters based on mathematical expressions. This module is designed to work with raster . The functions here include contrast enhancement, spectral filtering, and band arithmetic. Not a great fan of these but might be handy sometime</p>"},{"location":"reference/#nickyspatial.filters.spatial.merge_small_segments","title":"<code>merge_small_segments(source_layer, min_size, attribute='area_pixels', layer_manager=None, layer_name=None)</code>","text":"<p>Merge small segments with their largest neighbor.</p>"},{"location":"reference/#nickyspatial.filters.spatial.merge_small_segments--parameters","title":"Parameters:","text":"<p>source_layer : Layer     Source layer with segments to merge min_size : float     Minimum segment size threshold attribute : str     Attribute to use for size comparison layer_manager : LayerManager, optional     Layer manager to add the result layer to layer_name : str, optional     Name for the result layer</p>"},{"location":"reference/#nickyspatial.filters.spatial.merge_small_segments--returns","title":"Returns:","text":"<p>result_layer : Layer     Layer with merged segments</p> Source code in <code>nickyspatial/filters/spatial.py</code> <pre><code>def merge_small_segments(source_layer, min_size, attribute=\"area_pixels\", layer_manager=None, layer_name=None):\n    \"\"\"Merge small segments with their largest neighbor.\n\n    Parameters:\n    -----------\n    source_layer : Layer\n        Source layer with segments to merge\n    min_size : float\n        Minimum segment size threshold\n    attribute : str\n        Attribute to use for size comparison\n    layer_manager : LayerManager, optional\n        Layer manager to add the result layer to\n    layer_name : str, optional\n        Name for the result layer\n\n    Returns:\n    --------\n    result_layer : Layer\n        Layer with merged segments\n    \"\"\"\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_merged\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"filter\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n\n    result_layer.metadata = {\n        \"filter_type\": \"merge_small_segments\",\n        \"min_size\": min_size,\n        \"attribute\": attribute,\n    }\n\n    objects = source_layer.objects.copy()\n    small_segments = objects[objects[attribute] &lt; min_size]\n\n    if len(small_segments) == 0:\n        result_layer.objects = objects\n        result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n        if layer_manager:\n            layer_manager.add_layer(result_layer)\n\n        return result_layer\n\n    for idx, small_segment in small_segments.iterrows():\n        if idx not in objects.index:\n            continue\n\n        neighbors = objects[objects.index != idx].overlay(\n            gpd.GeoDataFrame(geometry=[small_segment.geometry], crs=objects.crs),\n            how=\"intersection\",\n        )\n\n        if len(neighbors) == 0:\n            continue\n\n        largest_neighbor_idx = neighbors[attribute].idxmax()\n\n        largest_neighbor = objects.loc[largest_neighbor_idx]\n        merged_geometry = largest_neighbor.geometry.union(small_segment.geometry)\n\n        objects.at[largest_neighbor_idx, \"geometry\"] = merged_geometry\n        objects.at[largest_neighbor_idx, attribute] += small_segment[attribute]\n\n        objects = objects.drop(idx)\n\n    if source_layer.raster is not None:\n        segments_raster = source_layer.raster.copy()\n\n        old_to_new = {}\n        for _idx, obj in objects.iterrows():\n            old_id = obj[\"segment_id\"]\n            old_to_new[old_id] = old_id\n\n        for idx, small_segment in small_segments.iterrows():\n            if idx not in objects.index:\n                old_id = small_segment[\"segment_id\"]\n\n                touching_segments = objects.intersects(small_segment.geometry)\n                if any(touching_segments):\n                    new_id = objects[touching_segments].iloc[0][\"segment_id\"]\n                    old_to_new[old_id] = new_id\n\n        for old_id, new_id in old_to_new.items():\n            if old_id != new_id:\n                segments_raster[segments_raster == old_id] = new_id\n\n        result_layer.raster = segments_raster\n\n    result_layer.objects = objects\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.filters.spatial.select_by_area","title":"<code>select_by_area(source_layer, min_area=None, max_area=None, area_column='area_units', layer_manager=None, layer_name=None)</code>","text":"<p>Select segments based on area.</p>"},{"location":"reference/#nickyspatial.filters.spatial.select_by_area--parameters","title":"Parameters:","text":"<p>source_layer : Layer     Source layer with segments to filter min_area : float, optional     Minimum area threshold max_area : float, optional     Maximum area threshold area_column : str     Column containing area values layer_manager : LayerManager, optional     Layer manager to add the result layer to layer_name : str, optional     Name for the result layer</p>"},{"location":"reference/#nickyspatial.filters.spatial.select_by_area--returns","title":"Returns:","text":"<p>result_layer : Layer     Layer with filtered segments</p> Source code in <code>nickyspatial/filters/spatial.py</code> <pre><code>def select_by_area(\n    source_layer,\n    min_area=None,\n    max_area=None,\n    area_column=\"area_units\",\n    layer_manager=None,\n    layer_name=None,\n):\n    \"\"\"Select segments based on area.\n\n    Parameters:\n    -----------\n    source_layer : Layer\n        Source layer with segments to filter\n    min_area : float, optional\n        Minimum area threshold\n    max_area : float, optional\n        Maximum area threshold\n    area_column : str\n        Column containing area values\n    layer_manager : LayerManager, optional\n        Layer manager to add the result layer to\n    layer_name : str, optional\n        Name for the result layer\n\n    Returns:\n    --------\n    result_layer : Layer\n        Layer with filtered segments\n    \"\"\"\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_area_filtered\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"filter\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n\n    result_layer.metadata = {\n        \"filter_type\": \"select_by_area\",\n        \"min_area\": min_area,\n        \"max_area\": max_area,\n        \"area_column\": area_column,\n    }\n\n    objects = source_layer.objects.copy()\n\n    if min_area is not None:\n        objects = objects[objects[area_column] &gt;= min_area]\n\n    if max_area is not None:\n        objects = objects[objects[area_column] &lt;= max_area]\n\n    result_layer.objects = objects\n\n    if source_layer.raster is not None:\n        kept_ids = set(objects[\"segment_id\"])\n\n        segments_raster = source_layer.raster.copy()\n        mask = np.isin(segments_raster, list(kept_ids))\n\n        segments_raster[~mask] = 0\n\n        result_layer.raster = segments_raster\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.filters.spatial.smooth_boundaries","title":"<code>smooth_boundaries(source_layer, iterations=1, layer_manager=None, layer_name=None)</code>","text":"<p>Smooth segment boundaries by applying morphological operations.</p>"},{"location":"reference/#nickyspatial.filters.spatial.smooth_boundaries--parameters","title":"Parameters:","text":"<p>source_layer : Layer     Source layer with segments to smooth iterations : int     Number of smoothing iterations to apply layer_manager : LayerManager, optional     Layer manager to add the result layer to layer_name : str, optional     Name for the result layer</p>"},{"location":"reference/#nickyspatial.filters.spatial.smooth_boundaries--returns","title":"Returns:","text":"<p>result_layer : Layer     Layer with smoothed segment boundaries</p> Source code in <code>nickyspatial/filters/spatial.py</code> <pre><code>def smooth_boundaries(source_layer, iterations=1, layer_manager=None, layer_name=None):\n    \"\"\"Smooth segment boundaries by applying morphological operations.\n\n    Parameters:\n    -----------\n    source_layer : Layer\n        Source layer with segments to smooth\n    iterations : int\n        Number of smoothing iterations to apply\n    layer_manager : LayerManager, optional\n        Layer manager to add the result layer to\n    layer_name : str, optional\n        Name for the result layer\n\n    Returns:\n    --------\n    result_layer : Layer\n        Layer with smoothed segment boundaries\n    \"\"\"\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_smoothed\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"filter\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n    result_layer.raster = source_layer.raster.copy() if source_layer.raster is not None else None\n\n    result_layer.metadata = {\n        \"filter_type\": \"smooth_boundaries\",\n        \"iterations\": iterations,\n    }\n\n    objects = source_layer.objects.copy()\n\n    smoothed_geometries = []\n    for geom in objects.geometry:\n        smoothed_geom = geom\n        for _ in range(iterations):\n            buffer_distance = np.sqrt(smoothed_geom.area) * 0.01\n            smoothed_geom = smoothed_geom.buffer(-buffer_distance).buffer(buffer_distance * 2)\n\n        if not smoothed_geom.is_valid:\n            smoothed_geom = smoothed_geom.buffer(0)\n\n        smoothed_geometries.append(smoothed_geom)\n\n    objects.geometry = smoothed_geometries\n    result_layer.objects = objects\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.filters.spectral.enhance_contrast","title":"<code>enhance_contrast(source_layer, percentile_min=2, percentile_max=98, layer_manager=None, layer_name=None)</code>","text":"<p>Enhance contrast in source layer raster data.</p>"},{"location":"reference/#nickyspatial.filters.spectral.enhance_contrast--parameters","title":"Parameters:","text":"<p>source_layer : Layer     Source layer with raster data percentile_min : float     Lower percentile for contrast stretching percentile_max : float     Upper percentile for contrast stretching layer_manager : LayerManager, optional     Layer manager to add the result layer to layer_name : str, optional     Name for the result layer</p>"},{"location":"reference/#nickyspatial.filters.spectral.enhance_contrast--returns","title":"Returns:","text":"<p>result_layer : Layer     Layer with enhanced contrast</p> Source code in <code>nickyspatial/filters/spectral.py</code> <pre><code>def enhance_contrast(\n    source_layer,\n    percentile_min=2,\n    percentile_max=98,\n    layer_manager=None,\n    layer_name=None,\n):\n    \"\"\"Enhance contrast in source layer raster data.\n\n    Parameters:\n    -----------\n    source_layer : Layer\n        Source layer with raster data\n    percentile_min : float\n        Lower percentile for contrast stretching\n    percentile_max : float\n        Upper percentile for contrast stretching\n    layer_manager : LayerManager, optional\n        Layer manager to add the result layer to\n    layer_name : str, optional\n        Name for the result layer\n\n    Returns:\n    --------\n    result_layer : Layer\n        Layer with enhanced contrast\n    \"\"\"\n    if source_layer.raster is None:\n        raise ValueError(\"Source layer must have raster data\")\n\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_enhanced\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"filter\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n    result_layer.objects = source_layer.objects.copy() if source_layer.objects is not None else None\n\n    result_layer.metadata = {\n        \"filter_type\": \"enhance_contrast\",\n        \"percentile_min\": percentile_min,\n        \"percentile_max\": percentile_max,\n    }\n\n    enhanced_raster = source_layer.raster.copy()\n\n    p_min = np.percentile(enhanced_raster, percentile_min)\n    p_max = np.percentile(enhanced_raster, percentile_max)\n\n    enhanced_raster = np.clip(enhanced_raster, p_min, p_max)\n    enhanced_raster = (enhanced_raster - p_min) / (p_max - p_min)\n\n    result_layer.raster = enhanced_raster\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre>"},{"location":"reference/#nickyspatial.filters.spectral.spectral_filter","title":"<code>spectral_filter(source_layer, expression, layer_manager=None, layer_name=None)</code>","text":"<p>Apply a spectral filter based on a mathematical expression.</p>"},{"location":"reference/#nickyspatial.filters.spectral.spectral_filter--parameters","title":"Parameters:","text":"<p>source_layer : Layer     Source layer with segment statistics expression : str     Mathematical expression to apply (e.g., \"NDVI &gt; 0.5\") layer_manager : LayerManager, optional     Layer manager to add the result layer to layer_name : str, optional     Name for the result layer</p>"},{"location":"reference/#nickyspatial.filters.spectral.spectral_filter--returns","title":"Returns:","text":"<p>result_layer : Layer     Layer with filtered segments</p> Source code in <code>nickyspatial/filters/spectral.py</code> <pre><code>def spectral_filter(source_layer, expression, layer_manager=None, layer_name=None):\n    \"\"\"Apply a spectral filter based on a mathematical expression.\n\n    Parameters:\n    -----------\n    source_layer : Layer\n        Source layer with segment statistics\n    expression : str\n        Mathematical expression to apply (e.g., \"NDVI &gt; 0.5\")\n    layer_manager : LayerManager, optional\n        Layer manager to add the result layer to\n    layer_name : str, optional\n        Name for the result layer\n\n    Returns:\n    --------\n    result_layer : Layer\n        Layer with filtered segments\n    \"\"\"\n    import numexpr as ne\n\n    if not layer_name:\n        layer_name = f\"{source_layer.name}_spectral_filtered\"\n\n    result_layer = Layer(name=layer_name, parent=source_layer, type=\"filter\")\n    result_layer.transform = source_layer.transform\n    result_layer.crs = source_layer.crs\n\n    result_layer.metadata = {\"filter_type\": \"spectral_filter\", \"expression\": expression}\n\n    objects = source_layer.objects.copy()\n\n    try:\n        local_dict = {col: objects[col].values for col in objects.columns if col != \"geometry\"}\n        mask = ne.evaluate(expression, local_dict=local_dict)\n        mask = np.array(mask, dtype=bool)\n\n        filtered_objects = objects.iloc[mask]\n        result_layer.objects = filtered_objects\n\n        if source_layer.raster is not None:\n            kept_ids = set(filtered_objects[\"segment_id\"])\n            segments_raster = source_layer.raster.copy()\n            raster_mask = np.isin(segments_raster, list(kept_ids))\n            segments_raster[~raster_mask] = 0\n            result_layer.raster = segments_raster\n\n    except Exception as e:\n        raise ValueError(f\"Error applying spectral filter: {str(e)}\") from e\n\n    if layer_manager:\n        layer_manager.add_layer(result_layer)\n\n    return result_layer\n</code></pre>"},{"location":"reference/#nickyspatialio","title":"<code>nickyspatial.io</code>","text":"<p>The io package contains modules for reading and writing both raster and vector data.</p> <p>It abstracts file operations and coordinate system handling to facilitate I/O tasks.</p> <p>Handles raster input and output operations, including reading and saving multi-band images.</p> <p>Functions in this module may also provide metadata parsing and coordinate transform tools.</p> <p>Manages vector data I/O, supporting formats like Shapefile and GeoJSON.</p> <p>This module typically offers utilities for handling attributes, geometries, and coordinate reference systems.</p>"},{"location":"reference/#nickyspatial.io.raster.layer_to_raster","title":"<code>layer_to_raster(layer, output_path, column=None, nodata=0)</code>","text":"<p>Save a layer to a raster file.</p>"},{"location":"reference/#nickyspatial.io.raster.layer_to_raster--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to save output_path : str     Path to the output raster file column : str, optional     Column to rasterize (if saving from vector objects) nodata : int or float, optional     No data value</p> Source code in <code>nickyspatial/io/raster.py</code> <pre><code>def layer_to_raster(layer, output_path, column=None, nodata=0):\n    \"\"\"Save a layer to a raster file.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to save\n    output_path : str\n        Path to the output raster file\n    column : str, optional\n        Column to rasterize (if saving from vector objects)\n    nodata : int or float, optional\n        No data value\n    \"\"\"\n    from rasterio import features\n\n    os.makedirs(os.path.dirname(output_path), exist_ok=True)\n\n    if layer.raster is not None and column is None:\n        write_raster(\n            output_path,\n            layer.raster.reshape(1, *layer.raster.shape),\n            layer.transform,\n            layer.crs,\n            nodata,\n        )\n        return\n\n    if layer.objects is not None and column is not None:\n        if column not in layer.objects.columns:\n            raise ValueError(f\"Column '{column}' not found in layer objects\")\n\n        objects = layer.objects\n        col_values = objects[column]\n        # Check if values are numeric\n        if np.issubdtype(col_values.dtype, np.number):\n            shapes = [(geom, float(val)) for geom, val in zip(objects.geometry, col_values, strict=False)]\n        else:\n            unique_vals = col_values.unique()\n            val_map = {val: idx for idx, val in enumerate(unique_vals)}\n            print(f\"Mapping categorical values: {val_map}\")\n            shapes = [(geom, val_map[val]) for geom, val in zip(objects.geometry, col_values, strict=False)]\n        if layer.raster is not None:\n            if len(layer.raster.shape) == 3:\n                height, width = layer.raster.shape[1], layer.raster.shape[2]\n            else:\n                height, width = layer.raster.shape\n            out_shape = (height, width)\n        else:\n            bounds = objects.total_bounds\n            resolution = 10\n            if layer.transform:\n                resolution = abs(layer.transform.a)\n            width = int((bounds[2] - bounds[0]) / resolution)\n            height = int((bounds[3] - bounds[1]) / resolution)\n            out_shape = (height, width)\n            if layer.transform is None:\n                layer.transform = from_origin(bounds[0], bounds[3], resolution, resolution)\n\n        output = np.ones(out_shape, dtype=np.float32) * nodata\n\n        features.rasterize(shapes, out=output, transform=layer.transform, fill=nodata)\n\n        write_raster(\n            output_path,\n            output.reshape(1, *out_shape),\n            layer.transform,\n            layer.crs,\n            nodata,\n        )\n    else:\n        raise ValueError(\"Layer must have either raster data or objects with a specified column\")\n</code></pre>"},{"location":"reference/#nickyspatial.io.raster.read_raster","title":"<code>read_raster(raster_path)</code>","text":"<p>Read a raster file and return its data, transform, and CRS.</p>"},{"location":"reference/#nickyspatial.io.raster.read_raster--parameters","title":"Parameters:","text":"<p>raster_path : str     Path to the raster file</p>"},{"location":"reference/#nickyspatial.io.raster.read_raster--returns","title":"Returns:","text":"<p>image_data : numpy.ndarray     Array with raster data values transform : affine.Affine     Affine transformation for the raster crs : rasterio.crs.CRS     Coordinate reference system</p> Source code in <code>nickyspatial/io/raster.py</code> <pre><code>def read_raster(raster_path):\n    \"\"\"Read a raster file and return its data, transform, and CRS.\n\n    Parameters:\n    -----------\n    raster_path : str\n        Path to the raster file\n\n    Returns:\n    --------\n    image_data : numpy.ndarray\n        Array with raster data values\n    transform : affine.Affine\n        Affine transformation for the raster\n    crs : rasterio.crs.CRS\n        Coordinate reference system\n    \"\"\"\n    with rasterio.open(raster_path) as src:\n        image_data = src.read()\n        transform = src.transform\n        crs = src.crs\n\n    return image_data, transform, crs\n</code></pre>"},{"location":"reference/#nickyspatial.io.raster.write_raster","title":"<code>write_raster(output_path, data, transform, crs, nodata=None)</code>","text":"<p>Write raster data to a file.</p>"},{"location":"reference/#nickyspatial.io.raster.write_raster--parameters","title":"Parameters:","text":"<p>output_path : str     Path to the output raster file data : numpy.ndarray     Array with raster data values transform : affine.Affine     Affine transformation for the raster crs : rasterio.crs.CRS     Coordinate reference system nodata : int or float, optional     No data value</p> Source code in <code>nickyspatial/io/raster.py</code> <pre><code>def write_raster(output_path, data, transform, crs, nodata=None):\n    \"\"\"Write raster data to a file.\n\n    Parameters:\n    -----------\n    output_path : str\n        Path to the output raster file\n    data : numpy.ndarray\n        Array with raster data values\n    transform : affine.Affine\n        Affine transformation for the raster\n    crs : rasterio.crs.CRS\n        Coordinate reference system\n    nodata : int or float, optional\n        No data value\n    \"\"\"\n    os.makedirs(os.path.dirname(output_path), exist_ok=True)\n\n    if len(data.shape) == 2:\n        data = data.reshape(1, *data.shape)\n\n    height, width = data.shape[-2], data.shape[-1]\n    count = data.shape[0]\n\n    with rasterio.open(\n        output_path,\n        \"w\",\n        driver=\"GTiff\",\n        height=height,\n        width=width,\n        count=count,\n        dtype=data.dtype,\n        crs=crs,\n        transform=transform,\n        nodata=nodata,\n    ) as dst:\n        dst.write(data)\n</code></pre>"},{"location":"reference/#nickyspatial.io.vector.layer_to_vector","title":"<code>layer_to_vector(layer, output_path)</code>","text":"<p>Save a layer's objects to a vector file.</p>"},{"location":"reference/#nickyspatial.io.vector.layer_to_vector--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to save output_path : str     Path to the output vector file</p> Source code in <code>nickyspatial/io/vector.py</code> <pre><code>def layer_to_vector(layer, output_path):\n    \"\"\"Save a layer's objects to a vector file.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to save\n    output_path : str\n        Path to the output vector file\n    \"\"\"\n    if layer.objects is None:\n        raise ValueError(\"Layer has no vector objects\")\n\n    write_vector(layer.objects, output_path)\n</code></pre>"},{"location":"reference/#nickyspatial.io.vector.read_vector","title":"<code>read_vector(vector_path)</code>","text":"<p>Read a vector file into a GeoDataFrame.</p>"},{"location":"reference/#nickyspatial.io.vector.read_vector--parameters","title":"Parameters:","text":"<p>vector_path : str     Path to the vector file</p>"},{"location":"reference/#nickyspatial.io.vector.read_vector--returns","title":"Returns:","text":"<p>gdf : geopandas.GeoDataFrame     GeoDataFrame with vector data</p> Source code in <code>nickyspatial/io/vector.py</code> <pre><code>def read_vector(vector_path):\n    \"\"\"Read a vector file into a GeoDataFrame.\n\n    Parameters:\n    -----------\n    vector_path : str\n        Path to the vector file\n\n    Returns:\n    --------\n    gdf : geopandas.GeoDataFrame\n        GeoDataFrame with vector data\n    \"\"\"\n    return gpd.read_file(vector_path)\n</code></pre>"},{"location":"reference/#nickyspatial.io.vector.write_vector","title":"<code>write_vector(gdf, output_path)</code>","text":"<p>Write a GeoDataFrame to a vector file.</p>"},{"location":"reference/#nickyspatial.io.vector.write_vector--parameters","title":"Parameters:","text":"<p>gdf : geopandas.GeoDataFrame     GeoDataFrame to write output_path : str     Path to the output vector file</p> Source code in <code>nickyspatial/io/vector.py</code> <pre><code>def write_vector(gdf, output_path):\n    \"\"\"Write a GeoDataFrame to a vector file.\n\n    Parameters:\n    -----------\n    gdf : geopandas.GeoDataFrame\n        GeoDataFrame to write\n    output_path : str\n        Path to the output vector file\n    \"\"\"\n    os.makedirs(os.path.dirname(output_path), exist_ok=True)\n    file_extension = os.path.splitext(output_path)[1].lower()\n\n    if file_extension == \".shp\":\n        gdf.to_file(output_path)\n    elif file_extension == \".geojson\":\n        gdf.to_file(output_path, driver=\"GeoJSON\")\n    else:\n        raise ValueError(f\"Unsupported vector format: {file_extension}\")\n</code></pre>"},{"location":"reference/#nickyspatialstats","title":"<code>nickyspatial.stats</code>","text":"<p>The stats package includes modules for calculating statistical metrics on objects.</p> <p>This is to mimic the stats module in ecognition because they will be necessary in order to apply rules later on and extremely essential to work with objects</p> <p>Basic statistics for layers in NickySpatial.</p> <p>Spatial statistics for layers in NickySpatial.</p> <p>Spectral indices calculation module.</p>"},{"location":"reference/#nickyspatial.stats.basic.attach_basic_stats","title":"<code>attach_basic_stats(layer, column, prefix=None)</code>","text":"<p>Attach basic statistics for a column to a layer.</p>"},{"location":"reference/#nickyspatial.stats.basic.attach_basic_stats--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to attach statistics to column : str     Column to calculate statistics for prefix : str, optional     Prefix for result names</p>"},{"location":"reference/#nickyspatial.stats.basic.attach_basic_stats--returns","title":"Returns:","text":"<p>stats : dict     Dictionary with calculated statistics</p> Source code in <code>nickyspatial/stats/basic.py</code> <pre><code>def attach_basic_stats(layer, column, prefix=None):\n    \"\"\"Attach basic statistics for a column to a layer.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to attach statistics to\n    column : str\n        Column to calculate statistics for\n    prefix : str, optional\n        Prefix for result names\n\n    Returns:\n    --------\n    stats : dict\n        Dictionary with calculated statistics\n    \"\"\"\n    if layer.objects is None or column not in layer.objects.columns:\n        raise ValueError(f\"Column '{column}' not found in layer objects\")\n\n    prefix = f\"{prefix}_\" if prefix else \"\"\n\n    values = layer.objects[column]\n    stats = {\n        f\"{prefix}min\": values.min(),\n        f\"{prefix}max\": values.max(),\n        f\"{prefix}mean\": values.mean(),\n        f\"{prefix}median\": values.median(),\n        f\"{prefix}std\": values.std(),\n        f\"{prefix}sum\": values.sum(),\n        f\"{prefix}count\": len(values),\n    }\n\n    percentiles = [10, 25, 50, 75, 90]\n    for p in percentiles:\n        stats[f\"{prefix}percentile_{p}\"] = np.percentile(values, p)\n\n    return stats\n</code></pre>"},{"location":"reference/#nickyspatial.stats.basic.attach_class_distribution","title":"<code>attach_class_distribution(layer, class_column='classification')</code>","text":"<p>Calculate the distribution of classes in a layer.</p>"},{"location":"reference/#nickyspatial.stats.basic.attach_class_distribution--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to analyze class_column : str     Column containing class values</p>"},{"location":"reference/#nickyspatial.stats.basic.attach_class_distribution--returns","title":"Returns:","text":"<p>distribution : dict     Dictionary with class counts and percentages</p> Source code in <code>nickyspatial/stats/basic.py</code> <pre><code>def attach_class_distribution(layer, class_column=\"classification\"):\n    \"\"\"Calculate the distribution of classes in a layer.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to analyze\n    class_column : str\n        Column containing class values\n\n    Returns:\n    --------\n    distribution : dict\n        Dictionary with class counts and percentages\n    \"\"\"\n    if layer.objects is None or class_column not in layer.objects.columns:\n        return {}\n\n    class_counts = layer.objects[class_column].value_counts()\n    total_count = len(layer.objects)\n    class_percentages = (class_counts / total_count * 100).round(2)\n\n    distribution = {\n        \"counts\": class_counts.to_dict(),\n        \"percentages\": class_percentages.to_dict(),\n        \"total\": total_count,\n    }\n\n    return distribution\n</code></pre>"},{"location":"reference/#nickyspatial.stats.basic.attach_count","title":"<code>attach_count(layer, class_column='classification', class_value=None)</code>","text":"<p>Count objects in a layer, optionally filtered by class.</p>"},{"location":"reference/#nickyspatial.stats.basic.attach_count--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to count objects in class_column : str     Column containing class values class_value : str, optional     Class value to filter by</p>"},{"location":"reference/#nickyspatial.stats.basic.attach_count--returns","title":"Returns:","text":"<p>count : int     Number of objects</p> Source code in <code>nickyspatial/stats/basic.py</code> <pre><code>def attach_count(layer, class_column=\"classification\", class_value=None):\n    \"\"\"Count objects in a layer, optionally filtered by class.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to count objects in\n    class_column : str\n        Column containing class values\n    class_value : str, optional\n        Class value to filter by\n\n    Returns:\n    --------\n    count : int\n        Number of objects\n    \"\"\"\n    if layer.objects is None:\n        return 0\n\n    if class_value is not None and class_column in layer.objects.columns:\n        count = layer.objects[layer.objects[class_column] == class_value].shape[0]\n    else:\n        count = layer.objects.shape[0]\n\n    return count\n</code></pre>"},{"location":"reference/#nickyspatial.stats.spatial.attach_area_stats","title":"<code>attach_area_stats(layer, area_column='area_units', by_class=None)</code>","text":"<p>Calculate area statistics for objects in a layer.</p>"},{"location":"reference/#nickyspatial.stats.spatial.attach_area_stats--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to calculate statistics for area_column : str     Column containing area values by_class : str, optional     Column to group by (e.g., 'classification')</p>"},{"location":"reference/#nickyspatial.stats.spatial.attach_area_stats--returns","title":"Returns:","text":"<p>stats : dict     Dictionary with area statistics</p> Source code in <code>nickyspatial/stats/spatial.py</code> <pre><code>def attach_area_stats(layer, area_column=\"area_units\", by_class=None):\n    \"\"\"Calculate area statistics for objects in a layer.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to calculate statistics for\n    area_column : str\n        Column containing area values\n    by_class : str, optional\n        Column to group by (e.g., 'classification')\n\n    Returns:\n    --------\n    stats : dict\n        Dictionary with area statistics\n    \"\"\"\n    if layer.objects is None or area_column not in layer.objects.columns:\n        return {}\n\n    total_area = layer.objects[area_column].sum()\n\n    if by_class and by_class in layer.objects.columns:\n        class_areas = {}\n        class_percentages = {}\n\n        for class_value, group in layer.objects.groupby(by_class):\n            if class_value is None:\n                continue\n\n            class_area = group[area_column].sum()\n            class_percentage = (class_area / total_area * 100).round(2)\n\n            class_areas[class_value] = class_area\n            class_percentages[class_value] = class_percentage\n\n        stats = {\n            \"total_area\": total_area,\n            \"class_areas\": class_areas,\n            \"class_percentages\": class_percentages,\n        }\n    else:\n        areas = layer.objects[area_column]\n\n        stats = {\n            \"total_area\": total_area,\n            \"min_area\": areas.min(),\n            \"max_area\": areas.max(),\n            \"mean_area\": areas.mean(),\n            \"median_area\": areas.median(),\n            \"std_area\": areas.std(),\n        }\n\n    return stats\n</code></pre>"},{"location":"reference/#nickyspatial.stats.spatial.attach_neighbor_stats","title":"<code>attach_neighbor_stats(layer)</code>","text":"<p>Calculate neighborhood statistics for objects in a layer.</p>"},{"location":"reference/#nickyspatial.stats.spatial.attach_neighbor_stats--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to calculate statistics for</p>"},{"location":"reference/#nickyspatial.stats.spatial.attach_neighbor_stats--returns","title":"Returns:","text":"<p>stats : dict     Dictionary with neighborhood statistics</p> Source code in <code>nickyspatial/stats/spatial.py</code> <pre><code>def attach_neighbor_stats(layer):\n    \"\"\"Calculate neighborhood statistics for objects in a layer.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to calculate statistics for\n\n    Returns:\n    --------\n    stats : dict\n        Dictionary with neighborhood statistics\n    \"\"\"\n    if layer.objects is None:\n        return {}\n\n    neighbors = {}\n    neighbor_counts = []\n\n    for idx, obj in layer.objects.iterrows():\n        touching = layer.objects[layer.objects.index != idx].intersects(obj.geometry)\n        neighbor_ids = layer.objects[touching].index.tolist()\n\n        neighbors[idx] = neighbor_ids\n        neighbor_counts.append(len(neighbor_ids))\n\n    layer.objects[\"neighbor_count\"] = neighbor_counts\n\n    stats = {\n        \"neighbor_count\": {\n            \"mean\": np.mean(neighbor_counts),\n            \"min\": np.min(neighbor_counts),\n            \"max\": np.max(neighbor_counts),\n            \"std\": np.std(neighbor_counts),\n        }\n    }\n\n    return stats\n</code></pre>"},{"location":"reference/#nickyspatial.stats.spatial.attach_shape_metrics","title":"<code>attach_shape_metrics(layer)</code>","text":"<p>Calculate shape metrics for objects in a layer.</p>"},{"location":"reference/#nickyspatial.stats.spatial.attach_shape_metrics--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to calculate metrics for</p>"},{"location":"reference/#nickyspatial.stats.spatial.attach_shape_metrics--returns","title":"Returns:","text":"<p>metrics : dict     Dictionary with shape metrics</p> Source code in <code>nickyspatial/stats/spatial.py</code> <pre><code>def attach_shape_metrics(layer):\n    \"\"\"Calculate shape metrics for objects in a layer.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to calculate metrics for\n\n    Returns:\n    --------\n    metrics : dict\n        Dictionary with shape metrics\n    \"\"\"\n    if layer.objects is None:\n        return {}\n\n    layer.objects[\"perimeter\"] = layer.objects.geometry.length\n\n    if \"area_units\" not in layer.objects.columns:\n        layer.objects[\"area_units\"] = layer.objects.geometry.area\n\n    layer.objects[\"shape_index\"] = (\n        (layer.objects[\"perimeter\"] / (2 * np.sqrt(np.pi * layer.objects[\"area_units\"])))\n        .replace([np.inf, -np.inf], np.nan)\n        .fillna(0)\n    )\n\n    layer.objects[\"compactness\"] = (\n        (4 * np.pi * layer.objects[\"area_units\"] / (layer.objects[\"perimeter\"] ** 2)).replace([np.inf, -np.inf], np.nan).fillna(0)\n    )\n\n    metrics = {\n        \"shape_index\": {\n            \"mean\": layer.objects[\"shape_index\"].mean(),\n            \"min\": layer.objects[\"shape_index\"].min(),\n            \"max\": layer.objects[\"shape_index\"].max(),\n            \"std\": layer.objects[\"shape_index\"].std(),\n        },\n        \"compactness\": {\n            \"mean\": layer.objects[\"compactness\"].mean(),\n            \"min\": layer.objects[\"compactness\"].min(),\n            \"max\": layer.objects[\"compactness\"].max(),\n            \"std\": layer.objects[\"compactness\"].std(),\n        },\n    }\n\n    return metrics\n</code></pre>"},{"location":"reference/#nickyspatial.stats.spectral.attach_ndvi","title":"<code>attach_ndvi(layer, nir_column='NIR_mean', red_column='Red_mean', output_column='NDVI')</code>","text":"<p>Calculate NDVI (Normalized Difference Vegetation Index) for objects in a layer.</p>"},{"location":"reference/#nickyspatial.stats.spectral.attach_ndvi--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to calculate NDVI for nir_column : str     Column containing NIR band values red_column : str     Column containing Red band values output_column : str     Column to store NDVI values</p>"},{"location":"reference/#nickyspatial.stats.spectral.attach_ndvi--returns","title":"Returns:","text":"<p>ndvi_stats : dict     Dictionary with NDVI statistics</p> Source code in <code>nickyspatial/stats/spectral.py</code> <pre><code>def attach_ndvi(layer, nir_column=\"NIR_mean\", red_column=\"Red_mean\", output_column=\"NDVI\"):\n    \"\"\"Calculate NDVI (Normalized Difference Vegetation Index) for objects in a layer.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to calculate NDVI for\n    nir_column : str\n        Column containing NIR band values\n    red_column : str\n        Column containing Red band values\n    output_column : str\n        Column to store NDVI values\n\n    Returns:\n    --------\n    ndvi_stats : dict\n        Dictionary with NDVI statistics\n    \"\"\"\n    if layer.objects is None or nir_column not in layer.objects.columns or red_column not in layer.objects.columns:\n        return {}\n\n    nir = layer.objects[nir_column]\n    red = layer.objects[red_column]\n\n    denominator = nir + red\n    mask = denominator != 0\n\n    ndvi = np.zeros(len(layer.objects))\n    ndvi[mask] = (nir[mask] - red[mask]) / denominator[mask]\n\n    layer.objects[output_column] = ndvi\n\n    ndvi_stats = {\n        \"mean\": ndvi.mean(),\n        \"min\": ndvi.min(),\n        \"max\": ndvi.max(),\n        \"std\": np.std(ndvi),\n        \"median\": np.median(ndvi),\n    }\n\n    return ndvi_stats\n</code></pre>"},{"location":"reference/#nickyspatial.stats.spectral.attach_spectral_indices","title":"<code>attach_spectral_indices(layer, bands=None)</code>","text":"<p>Calculate multiple spectral indices for objects in a layer.</p>"},{"location":"reference/#nickyspatial.stats.spectral.attach_spectral_indices--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to calculate indices for bands : dict, optional     Dictionary mapping band names to column names</p>"},{"location":"reference/#nickyspatial.stats.spectral.attach_spectral_indices--returns","title":"Returns:","text":"<p>indices : dict     Dictionary with calculated indices</p> Source code in <code>nickyspatial/stats/spectral.py</code> <pre><code>def attach_spectral_indices(layer, bands=None):\n    \"\"\"Calculate multiple spectral indices for objects in a layer.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to calculate indices for\n    bands : dict, optional\n        Dictionary mapping band names to column names\n\n    Returns:\n    --------\n    indices : dict\n        Dictionary with calculated indices\n    \"\"\"\n    if layer.objects is None:\n        return {}\n\n    if bands is None:\n        bands = {\n            \"blue\": \"Blue_mean\",\n            \"green\": \"Green_mean\",\n            \"red\": \"Red_mean\",\n            \"nir\": \"NIR_mean\",\n        }\n\n    for _band_name, column in bands.items():\n        if column not in layer.objects.columns:\n            print(f\"Warning: Band column '{column}' not found. Some indices may not be calculated.\")\n\n    indices = {}\n\n    # NDVI (Normalized Difference Vegetation Index)\n    if \"nir\" in bands and \"red\" in bands:\n        if bands[\"nir\"] in layer.objects.columns and bands[\"red\"] in layer.objects.columns:\n            ndvi = attach_ndvi(layer, bands[\"nir\"], bands[\"red\"], \"NDVI\")\n            indices[\"NDVI\"] = ndvi\n\n    # NDWI (Normalized Difference Water Index)\n    if \"green\" in bands and \"nir\" in bands:\n        if bands[\"green\"] in layer.objects.columns and bands[\"nir\"] in layer.objects.columns:\n            green = layer.objects[bands[\"green\"]]\n            nir = layer.objects[bands[\"nir\"]]\n\n            denominator = green + nir\n            mask = denominator != 0\n\n            ndwi = np.zeros(len(layer.objects))\n            ndwi[mask] = (green[mask] - nir[mask]) / denominator[mask]\n\n            layer.objects[\"NDWI\"] = ndwi\n\n            indices[\"NDWI\"] = {\n                \"mean\": ndwi.mean(),\n                \"min\": ndwi.min(),\n                \"max\": ndwi.max(),\n                \"std\": np.std(ndwi),\n            }\n\n    return indices\n</code></pre>"},{"location":"reference/#nickyspatialutils","title":"<code>nickyspatial.utils</code>","text":"<p>This modules contains utility functions for handling attributes, geometries, and coordinate reference systems.</p> <p>Helpers , Aren't they useful ?</p>"},{"location":"reference/#nickyspatial.utils.helpers.calculate_statistics_summary","title":"<code>calculate_statistics_summary(layer_manager, output_file=None)</code>","text":"<p>Calculate summary statistics for all layers in a layer manager.</p>"},{"location":"reference/#nickyspatial.utils.helpers.calculate_statistics_summary--parameters","title":"Parameters:","text":"<p>layer_manager : LayerManager     Layer manager containing layers output_file : str, optional     Path to save the summary to (as JSON)</p>"},{"location":"reference/#nickyspatial.utils.helpers.calculate_statistics_summary--returns","title":"Returns:","text":"<p>summary : dict     Dictionary with summary statistics</p> Source code in <code>nickyspatial/utils/helpers.py</code> <pre><code>def calculate_statistics_summary(layer_manager, output_file=None):\n    \"\"\"Calculate summary statistics for all layers in a layer manager.\n\n    Parameters:\n    -----------\n    layer_manager : LayerManager\n        Layer manager containing layers\n    output_file : str, optional\n        Path to save the summary to (as JSON)\n\n    Returns:\n    --------\n    summary : dict\n        Dictionary with summary statistics\n    \"\"\"\n    summary = {}\n\n    for layer_name in layer_manager.get_layer_names():\n        layer = layer_manager.get_layer(layer_name)\n\n        layer_summary = {\n            \"type\": layer.type,\n            \"created_at\": str(layer.created_at),\n            \"parent\": layer.parent.name if layer.parent else None,\n        }\n\n        if layer.objects is not None:\n            layer_summary[\"object_count\"] = len(layer.objects)\n\n            if \"area_units\" in layer.objects.columns:\n                layer_summary[\"total_area\"] = float(layer.objects[\"area_units\"].sum())\n                layer_summary[\"mean_area\"] = float(layer.objects[\"area_units\"].mean())\n\n            for col in layer.objects.columns:\n                if col.lower().endswith(\"class\") or col.lower() == \"classification\":\n                    class_counts = layer.objects[col].value_counts().to_dict()\n                    layer_summary[f\"{col}_counts\"] = {str(k): int(v) for k, v in class_counts.items() if k is not None}\n\n        if layer.attached_functions:\n            layer_summary[\"functions\"] = list(layer.attached_functions.keys())\n\n        summary[layer_name] = layer_summary\n\n    if output_file:\n        os.makedirs(os.path.dirname(output_file), exist_ok=True)\n        with open(output_file, \"w\") as f:\n            json.dump(summary, f, indent=2)\n\n    return summary\n</code></pre>"},{"location":"reference/#nickyspatial.utils.helpers.create_sample_data","title":"<code>create_sample_data()</code>","text":"<p>Create a synthetic 4-band (B, G, R, NIR) image for testing.</p>"},{"location":"reference/#nickyspatial.utils.helpers.create_sample_data--returns","title":"Returns:","text":"<p>image_data : numpy.ndarray     Synthetic image data transform : affine.Affine     Affine transformation for the raster crs : rasterio.crs.CRS     Coordinate reference system</p> Source code in <code>nickyspatial/utils/helpers.py</code> <pre><code>def create_sample_data():\n    \"\"\"Create a synthetic 4-band (B, G, R, NIR) image for testing.\n\n    Returns:\n    --------\n    image_data : numpy.ndarray\n        Synthetic image data\n    transform : affine.Affine\n        Affine transformation for the raster\n    crs : rasterio.crs.CRS\n        Coordinate reference system\n    \"\"\"\n    ## need to write logic for this one to create a pseduo image\n\n    # return image_data, transform, crs\n    return None\n</code></pre>"},{"location":"reference/#nickyspatial.utils.helpers.get_band_statistics","title":"<code>get_band_statistics(image_data, band_names=None)</code>","text":"<p>Calculate statistics for each band in a raster image.</p>"},{"location":"reference/#nickyspatial.utils.helpers.get_band_statistics--parameters","title":"Parameters:","text":"<p>image_data : numpy.ndarray     Raster image data (bands, height, width) band_names : list of str, optional     Names of the bands</p>"},{"location":"reference/#nickyspatial.utils.helpers.get_band_statistics--returns","title":"Returns:","text":"<p>stats : dict     Dictionary with band statistics</p> Source code in <code>nickyspatial/utils/helpers.py</code> <pre><code>def get_band_statistics(image_data, band_names=None):\n    \"\"\"Calculate statistics for each band in a raster image.\n\n    Parameters:\n    -----------\n    image_data : numpy.ndarray\n        Raster image data (bands, height, width)\n    band_names : list of str, optional\n        Names of the bands\n\n    Returns:\n    --------\n    stats : dict\n        Dictionary with band statistics\n    \"\"\"\n    num_bands = image_data.shape[0]\n\n    if band_names is None:\n        band_names = [f\"Band_{i + 1}\" for i in range(num_bands)]\n\n    stats = {}\n\n    for i, band_name in enumerate(band_names):\n        if i &gt;= num_bands:\n            break\n\n        band_data = image_data[i]\n        stats[band_name] = {\n            \"min\": float(np.min(band_data)),\n            \"max\": float(np.max(band_data)),\n            \"mean\": float(np.mean(band_data)),\n            \"std\": float(np.std(band_data)),\n            \"median\": float(np.median(band_data)),\n            \"percentile_5\": float(np.percentile(band_data, 5)),\n            \"percentile_95\": float(np.percentile(band_data, 95)),\n        }\n\n    return stats\n</code></pre>"},{"location":"reference/#nickyspatial.utils.helpers.memory_usage","title":"<code>memory_usage(layer)</code>","text":"<p>Estimate memory usage of a layer in MB.</p>"},{"location":"reference/#nickyspatial.utils.helpers.memory_usage--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer to calculate memory usage for</p>"},{"location":"reference/#nickyspatial.utils.helpers.memory_usage--returns","title":"Returns:","text":"<p>memory_mb : float     Estimated memory usage in MB</p> Source code in <code>nickyspatial/utils/helpers.py</code> <pre><code>def memory_usage(layer):\n    \"\"\"Estimate memory usage of a layer in MB.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer to calculate memory usage for\n\n    Returns:\n    --------\n    memory_mb : float\n        Estimated memory usage in MB\n    \"\"\"\n    import sys\n\n    memory = 0\n\n    if layer.raster is not None:\n        memory += layer.raster.nbytes\n\n    if layer.objects is not None:\n        for col in layer.objects.columns:\n            if col != \"geometry\":\n                memory += sys.getsizeof(layer.objects[col].values)\n\n        memory += len(layer.objects) * 1000\n    memory_mb = memory / (1024 * 1024)\n\n    return memory_mb\n</code></pre>"},{"location":"reference/#nickyspatialviz","title":"<code>nickyspatial.viz</code>","text":"<p>Alrighty , let's get this visualization party started!</p> <p>No matter what you do you need to see it and present it , this is the module for it to contain all code about visualizaing the layers , object rule results etc.</p> <p>Visualization functions for plotting histograms, statistics, and scatter plots.</p> <p>Functions to create maps and visualize layers.</p>"},{"location":"reference/#nickyspatial.viz.charts.plot_histogram","title":"<code>plot_histogram(layer, attribute, bins=20, figsize=(10, 6), by_class=None)</code>","text":"<p>Plot a histogram of attribute values.</p>"},{"location":"reference/#nickyspatial.viz.charts.plot_histogram--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer containing data attribute : str     Attribute to plot bins : int     Number of bins figsize : tuple     Figure size by_class : str, optional     Column to group by (e.g., 'classification')</p>"},{"location":"reference/#nickyspatial.viz.charts.plot_histogram--returns","title":"Returns:","text":"<p>fig : matplotlib.figure.Figure     Figure object</p> Source code in <code>nickyspatial/viz/charts.py</code> <pre><code>def plot_histogram(layer, attribute, bins=20, figsize=(10, 6), by_class=None):\n    \"\"\"Plot a histogram of attribute values.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer containing data\n    attribute : str\n        Attribute to plot\n    bins : int\n        Number of bins\n    figsize : tuple\n        Figure size\n    by_class : str, optional\n        Column to group by (e.g., 'classification')\n\n    Returns:\n    --------\n    fig : matplotlib.figure.Figure\n        Figure object\n    \"\"\"\n    if layer.objects is None or attribute not in layer.objects.columns:\n        raise ValueError(f\"Attribute '{attribute}' not found in layer objects\")\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    if by_class and by_class in layer.objects.columns:\n        data = layer.objects[[attribute, by_class]].copy()\n\n        for class_value, group in data.groupby(by_class):\n            if class_value is None:\n                continue\n\n            sns.histplot(group[attribute], bins=bins, alpha=0.6, label=str(class_value), ax=ax)\n\n        ax.legend(title=by_class)\n    else:\n        sns.histplot(layer.objects[attribute], bins=bins, ax=ax)\n\n    ax.set_title(f\"Histogram of {attribute}\")\n    ax.set_xlabel(attribute)\n    ax.set_ylabel(\"Count\")\n\n    return fig\n</code></pre>"},{"location":"reference/#nickyspatial.viz.charts.plot_scatter","title":"<code>plot_scatter(layer, x_attribute, y_attribute, color_by=None, figsize=(10, 8))</code>","text":"<p>Create a scatter plot of two attributes.</p>"},{"location":"reference/#nickyspatial.viz.charts.plot_scatter--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer containing data x_attribute : str     Attribute for x-axis y_attribute : str     Attribute for y-axis color_by : str, optional     Attribute to color points by figsize : tuple     Figure size</p>"},{"location":"reference/#nickyspatial.viz.charts.plot_scatter--returns","title":"Returns:","text":"<p>fig : matplotlib.figure.Figure     Figure object</p> Source code in <code>nickyspatial/viz/charts.py</code> <pre><code>def plot_scatter(layer, x_attribute, y_attribute, color_by=None, figsize=(10, 8)):\n    \"\"\"Create a scatter plot of two attributes.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer containing data\n    x_attribute : str\n        Attribute for x-axis\n    y_attribute : str\n        Attribute for y-axis\n    color_by : str, optional\n        Attribute to color points by\n    figsize : tuple\n        Figure size\n\n    Returns:\n    --------\n    fig : matplotlib.figure.Figure\n        Figure object\n    \"\"\"\n    if layer.objects is None or x_attribute not in layer.objects.columns or y_attribute not in layer.objects.columns:\n        raise ValueError(\"Attributes not found in layer objects\")\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    if color_by and color_by in layer.objects.columns:\n        scatter = ax.scatter(\n            layer.objects[x_attribute],\n            layer.objects[y_attribute],\n            c=layer.objects[color_by],\n            cmap=\"viridis\",\n            alpha=0.7,\n            s=50,\n            edgecolor=\"k\",\n        )\n        cbar = plt.colorbar(scatter, ax=ax)\n        cbar.set_label(color_by)\n    else:\n        ax.scatter(\n            layer.objects[x_attribute],\n            layer.objects[y_attribute],\n            alpha=0.7,\n            s=50,\n            edgecolor=\"k\",\n        )\n\n    ax.set_title(f\"{y_attribute} vs {x_attribute}\")\n    ax.set_xlabel(x_attribute)\n    ax.set_ylabel(y_attribute)\n    ax.grid(alpha=0.3)\n\n    return fig\n</code></pre>"},{"location":"reference/#nickyspatial.viz.charts.plot_statistics","title":"<code>plot_statistics(layer, stats_dict, figsize=(12, 8), kind='bar', y_log=False)</code>","text":"<p>Plot statistics from a statistics dictionary.</p>"},{"location":"reference/#nickyspatial.viz.charts.plot_statistics--parameters","title":"Parameters:","text":"<p>layer : Layer     Layer the statistics are calculated for stats_dict : dict     Dictionary with statistics (from attach_* functions) figsize : tuple     Figure size kind : str     Plot type: 'bar', 'line', or 'pie' y_log : bool     Whether to use logarithmic scale for y-axis</p>"},{"location":"reference/#nickyspatial.viz.charts.plot_statistics--returns","title":"Returns:","text":"<p>fig : matplotlib.figure.Figure     Figure object</p> Source code in <code>nickyspatial/viz/charts.py</code> <pre><code>def plot_statistics(layer, stats_dict, figsize=(12, 8), kind=\"bar\", y_log=False):\n    \"\"\"Plot statistics from a statistics dictionary.\n\n    Parameters:\n    -----------\n    layer : Layer\n        Layer the statistics are calculated for\n    stats_dict : dict\n        Dictionary with statistics (from attach_* functions)\n    figsize : tuple\n        Figure size\n    kind : str\n        Plot type: 'bar', 'line', or 'pie'\n    y_log : bool\n        Whether to use logarithmic scale for y-axis\n\n    Returns:\n    --------\n    fig : matplotlib.figure.Figure\n        Figure object\n    \"\"\"\n    flat_stats = {}\n\n    def _flatten_dict(d, prefix=\"\"):\n        for key, value in d.items():\n            if isinstance(value, dict):\n                _flatten_dict(value, f\"{prefix}{key}_\")\n            else:\n                flat_stats[f\"{prefix}{key}\"] = value\n\n    _flatten_dict(stats_dict)\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    if kind == \"pie\" and \"class_percentages\" in stats_dict:\n        percentages = stats_dict[\"class_percentages\"]\n        values = list(percentages.values())\n        labels = list(percentages.keys())\n\n        ax.pie(values, labels=labels, autopct=\"%1.1f%%\", startangle=90, shadow=True)\n        ax.axis(\"equal\")\n        ax.set_title(\"Class Distribution\")\n\n    elif kind == \"pie\" and \"percentages\" in flat_stats:\n        percentages = pd.Series(flat_stats).filter(like=\"percentage\")\n        values = percentages.values\n        labels = [label.replace(\"_percentage\", \"\") for label in percentages.index]\n\n        ax.pie(values, labels=labels, autopct=\"%1.1f%%\", startangle=90, shadow=True)\n        ax.axis(\"equal\")\n        ax.set_title(\"Distribution\")\n\n    else:\n        stats_df = pd.DataFrame({\"Metric\": list(flat_stats.keys()), \"Value\": list(flat_stats.values())})\n\n        if kind != \"line\":\n            stats_df = stats_df.sort_values(\"Value\", ascending=False)\n\n        if kind == \"bar\":\n            sns.barplot(x=\"Metric\", y=\"Value\", data=stats_df, ax=ax)\n            ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\n        elif kind == \"line\":\n            sns.lineplot(x=\"Metric\", y=\"Value\", data=stats_df, ax=ax, marker=\"o\")\n            ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\n\n        if y_log:\n            ax.set_yscale(\"log\")\n\n        ax.set_title(\"Statistics Summary\")\n\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"reference/#nickyspatial.viz.maps.plot_classification","title":"<code>plot_classification(layer, class_field='classification', figsize=(12, 10), legend=True, class_color=None)</code>","text":"<p>Plot classified segments with different colors for each class.</p> Source code in <code>nickyspatial/viz/maps.py</code> <pre><code>def plot_classification(layer, class_field=\"classification\", figsize=(12, 10), legend=True, class_color=None):\n    \"\"\"Plot classified segments with different colors for each class.\"\"\"\n    fig, ax = plt.subplots(figsize=figsize)\n    if not class_color:\n        class_color = {}\n\n    if class_field not in layer.objects.columns:\n        raise ValueError(f\"Class field '{class_field}' not found in layer objects\")\n\n    class_values = [v for v in layer.objects[class_field].unique() if v is not None]\n\n    # generate base colormap\n    base_colors = plt.cm.tab20(np.linspace(0, 1, max(len(class_values), 1)))\n\n    colors_list = []\n    for idx, class_value in enumerate(class_values):\n        if class_color and class_value in list(class_color.keys()):\n            # reuse stored color\n            color_hex = class_color[class_value]\n        else:\n            # assign new color (from tab20 or random if exceeds)\n            if idx &lt; len(base_colors):\n                rgb = base_colors[idx][:3]\n                color_hex = \"#{:02x}{:02x}{:02x}\".format(int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255))\n            else:\n                color_hex = \"#{:06x}\".format(random.randint(0, 0xFFFFFF))\n            class_color[class_value] = color_hex\n\n        # convert hex \u2192 RGB tuple for ListedColormap\n        rgb_tuple = tuple(int(color_hex[i : i + 2], 16) / 255 for i in (1, 3, 5))\n        colors_list.append(rgb_tuple)\n\n    # create colormap\n    cmap = ListedColormap(colors_list)\n\n    # map class values to indices\n    class_map = {value: i for i, value in enumerate(class_values)}\n    layer.objects[\"_class_id\"] = layer.objects[class_field].map(class_map)\n\n    layer.objects.plot(\n        column=\"_class_id\",\n        cmap=cmap,\n        ax=ax,\n        edgecolor=\"black\",\n        linewidth=0.5,\n        legend=False,\n    )\n\n    if legend and len(class_values) &gt; 0:\n        patches = [mpatches.Patch(color=class_color[value], label=value) for value in class_values]\n        ax.legend(handles=patches, loc=\"upper right\", title=class_field)\n\n    # ax.set_title(f\"Classification by {class_field}\")\n    ax.set_title(\"Classification Map\")\n\n    ax.set_xlabel(\"X Coordinate\")\n    ax.set_ylabel(\"Y Coordinate\")\n\n    # cleanup temporary column\n    if \"_class_id\" in layer.objects.columns:\n        layer.objects = layer.objects.drop(columns=[\"_class_id\"])\n\n    return fig\n</code></pre>"},{"location":"reference/#nickyspatial.viz.maps.plot_comparison","title":"<code>plot_comparison(before_layer, after_layer, attribute=None, class_field=None, figsize=(16, 8), title=None)</code>","text":"<p>Plot before and after views of layers for comparison.</p> Source code in <code>nickyspatial/viz/maps.py</code> <pre><code>def plot_comparison(\n    before_layer,\n    after_layer,\n    attribute=None,\n    class_field=None,\n    figsize=(16, 8),\n    title=None,\n):\n    \"\"\"Plot before and after views of layers for comparison.\"\"\"\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize)\n\n    if title:\n        fig.suptitle(title)\n\n    if attribute and attribute in before_layer.objects.columns:\n        before_layer.objects.plot(column=attribute, ax=ax1, legend=True)\n        ax1.set_title(f\"Before: {attribute}\")\n    elif class_field and class_field in before_layer.objects.columns:\n        class_values = [v for v in before_layer.objects[class_field].unique() if v is not None]\n        num_classes = len(class_values)\n        colors = plt.cm.tab20(np.linspace(0, 1, max(num_classes, 1)))\n        cmap = ListedColormap(colors)\n        class_map = {value: i for i, value in enumerate(class_values)}\n        before_layer.objects[\"_class_id\"] = before_layer.objects[class_field].map(class_map)\n\n        before_layer.objects.plot(\n            column=\"_class_id\",\n            cmap=cmap,\n            ax=ax1,\n            edgecolor=\"black\",\n            linewidth=0.5,\n            legend=False,\n        )\n\n        patches = [mpatches.Patch(color=colors[i], label=value) for i, value in enumerate(class_values)]\n        ax1.legend(handles=patches, loc=\"upper right\", title=class_field)\n        ax1.set_title(f\"Before: {class_field}\")\n    else:\n        before_layer.objects.plot(ax=ax1)\n        ax1.set_title(\"Before\")\n\n    if attribute and attribute in after_layer.objects.columns:\n        after_layer.objects.plot(column=attribute, ax=ax2, legend=True)\n        ax2.set_title(f\"After: {attribute}\")\n    elif class_field and class_field in after_layer.objects.columns:\n        class_values = [v for v in after_layer.objects[class_field].unique() if v is not None]\n        num_classes = len(class_values)\n        colors = plt.cm.tab20(np.linspace(0, 1, max(num_classes, 1)))\n        cmap = ListedColormap(colors)\n        class_map = {value: i for i, value in enumerate(class_values)}\n        after_layer.objects[\"_class_id\"] = after_layer.objects[class_field].map(class_map)\n\n        after_layer.objects.plot(\n            column=\"_class_id\",\n            cmap=cmap,\n            ax=ax2,\n            edgecolor=\"black\",\n            linewidth=0.5,\n            legend=False,\n        )\n\n        patches = [mpatches.Patch(color=colors[i], label=value) for i, value in enumerate(class_values)]\n        ax2.legend(handles=patches, loc=\"upper right\", title=class_field)\n        ax2.set_title(f\"After: {class_field}\")\n    else:\n        after_layer.objects.plot(ax=ax2)\n        ax2.set_title(\"After\")\n\n    if \"_class_id\" in before_layer.objects.columns:\n        before_layer.objects = before_layer.objects.drop(columns=[\"_class_id\"])\n    if \"_class_id\" in after_layer.objects.columns:\n        after_layer.objects = after_layer.objects.drop(columns=[\"_class_id\"])\n\n    return fig\n</code></pre>"},{"location":"reference/#nickyspatial.viz.maps.plot_layer","title":"<code>plot_layer(layer, image_data=None, attribute=None, title=None, rgb_bands=(2, 1, 0), figsize=(12, 10), cmap='viridis', show_boundaries=False)</code>","text":"<p>Plot a layer, optionally with an attribute or image backdrop.</p> Source code in <code>nickyspatial/viz/maps.py</code> <pre><code>def plot_layer(\n    layer,\n    image_data=None,\n    attribute=None,\n    title=None,\n    rgb_bands=(2, 1, 0),\n    figsize=(12, 10),\n    cmap=\"viridis\",\n    show_boundaries=False,\n):\n    \"\"\"Plot a layer, optionally with an attribute or image backdrop.\"\"\"\n    fig, ax = plt.subplots(figsize=figsize)\n\n    if title:\n        ax.set_title(title)\n    elif attribute:\n        ax.set_title(f\"{attribute} by Segment\")\n    else:\n        ax.set_title(\"Layer Visualization\")\n\n    if image_data is not None:\n        num_bands = image_data.shape[0]\n        if num_bands &gt;= 3 and max(rgb_bands) &lt; num_bands:\n            r = image_data[rgb_bands[0]]\n            g = image_data[rgb_bands[1]]\n            b = image_data[rgb_bands[2]]\n\n            r_norm = np.clip((r - r.min()) / (r.max() - r.min() + 1e-10), 0, 1)\n            g_norm = np.clip((g - g.min()) / (g.max() - g.min() + 1e-10), 0, 1)\n            b_norm = np.clip((b - b.min()) / (b.max() - b.min() + 1e-10), 0, 1)\n\n            rgb = np.stack([r_norm, g_norm, b_norm], axis=2)\n\n            ax.imshow(rgb)\n        else:\n            gray = image_data[0]\n            gray_norm = (gray - gray.min()) / (gray.max() - gray.min() + 1e-10)\n            ax.imshow(gray_norm, cmap=\"gray\")\n\n    if attribute and attribute in layer.objects.columns:\n        layer.objects.plot(\n            column=attribute,\n            cmap=cmap,\n            ax=ax,\n            legend=True,\n            alpha=0.7 if image_data is not None else 1.0,\n        )\n\n    if show_boundaries and layer.raster is not None:\n        from skimage.segmentation import mark_boundaries\n\n        if image_data is not None:\n            if \"num_bands\" in locals() and num_bands &gt;= 3:\n                base_img = rgb\n            else:\n                gray = image_data[0]\n                gray_norm = (gray - gray.min()) / (gray.max() - gray.min() + 1e-10)\n                base_img = np.stack([gray_norm, gray_norm, gray_norm], axis=2)\n\n            bounded = mark_boundaries(base_img, layer.raster, color=(1, 1, 0), mode=\"thick\")\n\n            if attribute is None:\n                ax.imshow(bounded)\n        else:\n            ax.imshow(\n                mark_boundaries(\n                    np.zeros((layer.raster.shape[0], layer.raster.shape[1], 3)),\n                    layer.raster,\n                    color=(1, 1, 0),\n                    mode=\"thick\",\n                )\n            )\n\n    ax.grid(alpha=0.3)\n    return fig\n</code></pre>"},{"location":"reference/#nickyspatial.viz.maps.plot_layer_interactive","title":"<code>plot_layer_interactive(layer, image_data=None, figsize=(10, 8))</code>","text":"<p>Interactive plot of a layer with widgets and working click.</p> Source code in <code>nickyspatial/viz/maps.py</code> <pre><code>def plot_layer_interactive(layer, image_data=None, figsize=(10, 8)):\n    \"\"\"Interactive plot of a layer with widgets and working click.\"\"\"\n    \"\"\"\n    %matplotlib widget\n    plot_layer_interactive(layer=segmentation_layer,image_data=image_data,figsize=(10,8))\n    Not supported in google collab\n    \"\"\"\n    # attribute_options = [None] + list(layer.objects.columns)\n    # attribute_widget = widgets.Dropdown(\n    #     options=attribute_options,\n    #     value=None,\n    #     description='Attribute:'\n    # )\n\n    title_widget = widgets.Text(value=\"Layer Visualization\", description=\"Title:\")\n\n    # cmap_widget = widgets.Dropdown(\n    #     options=plt.colormaps(),\n    #     value='viridis',\n    #     description='Colormap:'\n    # )\n\n    rgb_band_max = image_data.shape[0] - 1 if image_data is not None else 2\n\n    # # Ensure that the default value is within the valid range\n    # default_value = (2, 1, 0) if rgb_band_max &gt;= 2 else (0,)\n\n    # # Create the widget with the correct range and default value\n    # red_band_widget = widgets.Select(\n    #     options=list(range(rgb_band_max + 1)),  # This ensures valid options based on the shape of the image\n    #     value=default_value[:rgb_band_max + 1],  # This makes sure the default value matches the options available\n    #     description='Red Band:'\n    # )\n\n    # rgb_band_max = image_data.shape[0] - 1 if image_data is not None else 2\n    red_band_widget = widgets.Select(\n        options=list(range(rgb_band_max + 1)), value=0 if rgb_band_max &gt;= 2 else 0, description=\"Red Band:\"\n    )\n    green_band_widget = widgets.Select(\n        options=list(range(rgb_band_max + 1)), value=1 if rgb_band_max &gt;= 2 else 0, description=\"Green Band:\"\n    )\n    blue_band_widget = widgets.Select(\n        options=list(range(rgb_band_max + 1)), value=2 if rgb_band_max &gt;= 2 else 0, description=\"Blue Band:\"\n    )\n\n    show_boundaries_widget = widgets.Checkbox(value=True, description=\"Show Boundaries\")\n\n    # Create a figure and output widget\n    fig, ax = plt.subplots(figsize=figsize)\n    out_fig = widgets.Output()\n\n    # with out_fig:\n    #     display(fig)\n\n    def onclick(event):\n        if event.xdata is None or event.ydata is None:\n            return\n        x_pix, y_pix = int(event.xdata), int(event.ydata)\n        if (0 &lt;= x_pix &lt; layer.raster.shape[1]) and (0 &lt;= y_pix &lt; layer.raster.shape[0]):\n            segment_id = layer.raster[y_pix, x_pix]\n            msg = f\"Clicked at (x={x_pix}, y={y_pix}) \u2192 Segment ID: {segment_id}\"\n            title_widget.value = msg\n            ax.set_title(msg)\n            fig.canvas.draw_idle()\n        else:\n            msg = \"Clicked outside raster bounds\"\n            title_widget.value = msg\n            ax.set_title(msg)\n            fig.canvas.draw_idle()\n\n    fig.canvas.mpl_connect(\"button_press_event\", onclick)\n\n    def update_plot(red_band, green_band, blue_band, show_boundaries):\n        # def update_plot(attribute, title, cmap, rgb_bands, show_boundaries):\n\n        ax.clear()\n        # ax.set_title(title)\n\n        if image_data is not None:\n            num_bands = image_data.shape[0]\n            if red_band &gt;= 0 and green_band &gt;= 0 and blue_band &gt;= 0:\n                r = image_data[red_band].astype(float)\n                g = image_data[green_band].astype(float)\n                b = image_data[blue_band].astype(float)\n\n                r_norm = np.clip((r - r.min()) / (r.max() - r.min() + 1e-10), 0, 1)\n                g_norm = np.clip((g - g.min()) / (g.max() - g.min() + 1e-10), 0, 1)\n                b_norm = np.clip((b - b.min()) / (b.max() - b.min() + 1e-10), 0, 1)\n\n                rgb = np.stack([r_norm, g_norm, b_norm], axis=2)\n                ax.imshow(rgb)\n            else:\n                gray = image_data[0]\n                gray_norm = (gray - gray.min()) / (gray.max() - gray.min() + 1e-10)\n                ax.imshow(gray_norm, cmap=\"gray\")\n\n        # if attribute and attribute in layer.objects.columns:\n        #     layer.objects.plot(\n        #         column=attribute,\n        #         cmap=cmap,\n        #         ax=ax,\n        #         legend=True,\n        #         alpha=0.7 if image_data is not None else 1.0,\n        #     )\n\n        if show_boundaries and layer.raster is not None:  # show_boundaries and\n            if image_data is not None:\n                if num_bands &gt;= 3:  # and len(rgb_bands) &gt;= 3:\n                    base_img = rgb\n                else:\n                    gray = image_data[0]\n                    gray_norm = (gray - gray.min()) / (gray.max() - gray.min() + 1e-10)\n                    base_img = np.stack([gray_norm, gray_norm, gray_norm], axis=2)\n\n                bounded = mark_boundaries(base_img, layer.raster, color=(1, 1, 0), mode=\"thick\")\n                # if attribute is None:\n                ax.imshow(bounded)\n            else:\n                ax.imshow(\n                    mark_boundaries(\n                        np.zeros((layer.raster.shape[0], layer.raster.shape[1], 3)),\n                        layer.raster,\n                        color=(1, 1, 0),\n                        mode=\"thick\",\n                    )\n                )\n\n        ax.grid(alpha=0.3)\n        fig.canvas.draw_idle()\n\n    # Zoom control widgets (manual)\n    # zoom_in_button = widgets.Button(description=\"Zoom In\")\n    # zoom_out_button = widgets.Button(description=\"Zoom Out\")\n\n    # def zoom_in(change):\n    #     xlim, ylim = ax.get_xlim(), ax.get_ylim()\n    #     ax.set_xlim(xlim[0] * 0.9, xlim[1] * 0.9)\n    #     ax.set_ylim(ylim[0] * 0.9, ylim[1] * 0.9)\n    #     fig.canvas.draw_idle()\n\n    # def zoom_out(change):\n    #     xlim, ylim = ax.get_xlim(), ax.get_ylim()\n    #     ax.set_xlim(xlim[0] * 1.1, xlim[1] * 1.1)\n    #     ax.set_ylim(ylim[0] * 1.1, ylim[1] * 1.1)\n    #     fig.canvas.draw_idle()\n\n    # zoom_in_button.on_click(zoom_in)\n    # zoom_out_button.on_click(zoom_out)\n\n    ui = widgets.VBox(\n        [\n            # attribute_widget,\n            # title_widget,\n            # cmap_widget,\n            red_band_widget,\n            green_band_widget,\n            blue_band_widget,\n            show_boundaries_widget,\n            # zoom_in_button,\n            # zoom_out_button,\n        ]\n    )\n\n    controls = widgets.interactive_output(\n        update_plot,\n        {\n            # 'attribute': attribute_widget,\n            # 'title': title_widget,\n            # 'cmap': cmap_widget,\n            \"red_band\": red_band_widget,\n            \"green_band\": green_band_widget,\n            \"blue_band\": blue_band_widget,\n            \"show_boundaries\": show_boundaries_widget,\n        },\n    )\n\n    display(ui, out_fig, controls)\n</code></pre>"},{"location":"reference/#nickyspatial.viz.maps.plot_layer_interactive_plotly","title":"<code>plot_layer_interactive_plotly(layer, image_data, rgb_bands=(0, 1, 2), show_boundaries=True, figsize=(800, 400))</code>","text":"<p>Display an interactive RGB image with segment boundaries and hoverable segment IDs using Plotly.</p> <p>Run in google collab as well.</p>"},{"location":"reference/#nickyspatial.viz.maps.plot_layer_interactive_plotly--parameters","title":"Parameters:","text":"<p>layer : object     An object with a <code>.raster</code> attribute representing the labeled segmentation layer     (e.g., output from a segmentation algorithm, such as SLIC). image_data : image data to be visualized. rgb_bands : tuple of int, optional     Tuple of three integers specifying which bands to use for the RGB composite (default is (0, 1, 2)). show_boundaries : bool, optional     Whether to overlay the segment boundaries on the RGB image (default is True). figsize : tuple of int, optional     Tuple specifying the width and height of the interactive Plotly figure in pixels (default is (800, 400)).</p>"},{"location":"reference/#nickyspatial.viz.maps.plot_layer_interactive_plotly--returns","title":"Returns:","text":"<p>None     The function displays the interactive plot directly in the output cell in a Jupyter Notebook.</p>"},{"location":"reference/#nickyspatial.viz.maps.plot_layer_interactive_plotly--notes","title":"Notes:","text":"<ul> <li>Segment boundaries are drawn using <code>skimage.segmentation.mark_boundaries</code>.</li> <li>Hovering over the image displays the segment ID from <code>layer.raster</code>.</li> </ul> Source code in <code>nickyspatial/viz/maps.py</code> <pre><code>def plot_layer_interactive_plotly(layer, image_data, rgb_bands=(0, 1, 2), show_boundaries=True, figsize=(800, 400)):\n    \"\"\"Display an interactive RGB image with segment boundaries and hoverable segment IDs using Plotly.\n\n    Run in google collab as well.\n\n    Parameters:\n    ----------\n    layer : object\n        An object with a `.raster` attribute representing the labeled segmentation layer\n        (e.g., output from a segmentation algorithm, such as SLIC).\n    image_data : image data to be visualized.\n    rgb_bands : tuple of int, optional\n        Tuple of three integers specifying which bands to use for the RGB composite (default is (0, 1, 2)).\n    show_boundaries : bool, optional\n        Whether to overlay the segment boundaries on the RGB image (default is True).\n    figsize : tuple of int, optional\n        Tuple specifying the width and height of the interactive Plotly figure in pixels (default is (800, 400)).\n\n    Returns:\n    -------\n    None\n        The function displays the interactive plot directly in the output cell in a Jupyter Notebook.\n\n    Notes:\n    -----\n    - Segment boundaries are drawn using `skimage.segmentation.mark_boundaries`.\n    - Hovering over the image displays the segment ID from `layer.raster`.\n\n    \"\"\"\n\n    def get_rgb_image(r, g, b):\n        r_norm = np.clip((r - r.min()) / (r.max() - r.min() + 1e-10), 0, 1)\n        g_norm = np.clip((g - g.min()) / (g.max() - g.min() + 1e-10), 0, 1)\n        b_norm = np.clip((b - b.min()) / (b.max() - b.min() + 1e-10), 0, 1)\n        return np.stack([r_norm, g_norm, b_norm], axis=2)\n\n    def update_plot(rgb_bands, show_boundaries=True):\n        rgb_image = get_rgb_image(image_data[rgb_bands[0]], image_data[rgb_bands[1]], image_data[rgb_bands[2]])\n\n        if show_boundaries:\n            rgb_image = mark_boundaries(rgb_image, layer.raster, color=(1, 1, 0), mode=\"thick\")\n\n        fig = go.Figure(data=go.Image(z=(rgb_image * 255).astype(np.uint8)))\n\n        # Add segment ID overlay with hover\n        fig.add_trace(\n            go.Heatmap(\n                z=layer.raster,\n                opacity=0,\n                hoverinfo=\"z\",\n                showscale=False,\n                hovertemplate=\"Segment ID: %{z}&lt;extra&gt;&lt;/extra&gt;\",\n                colorscale=\"gray\",\n            )\n        )\n\n        fig.update_layout(\n            title=\"Hover to see Segment ID\", dragmode=\"pan\", margin=dict(l=0, r=0, t=30, b=0), height=figsize[1], width=figsize[0]\n        )\n        fig.update_xaxes(showticklabels=False)\n        fig.update_yaxes(showticklabels=False, scaleanchor=\"x\")\n\n        fig.show()\n\n    update_plot(rgb_bands=rgb_bands, show_boundaries=show_boundaries)\n</code></pre>"},{"location":"reference/#nickyspatial.viz.maps.plot_sample","title":"<code>plot_sample(layer, image_data=None, transform=None, rgb_bands=None, class_field='classification', figsize=(8, 6), class_color=None, legend=True)</code>","text":"<p>Plot classified segments on top of RGB or grayscale image data.</p> <p>Parameters: - layer: Layer object with .objects (GeoDataFrame) - image_data: 3D numpy array (bands, height, width) - transform: Affine transform for the image (needed to compute extent) - red_band, green_band, blue_band: indices for RGB bands</p> Source code in <code>nickyspatial/viz/maps.py</code> <pre><code>def plot_sample(\n    layer,\n    image_data=None,\n    transform=None,\n    rgb_bands=None,\n    class_field=\"classification\",\n    figsize=(8, 6),\n    class_color=None,\n    legend=True,\n):\n    \"\"\"Plot classified segments on top of RGB or grayscale image data.\n\n    Parameters:\n    - layer: Layer object with .objects (GeoDataFrame)\n    - image_data: 3D numpy array (bands, height, width)\n    - transform: Affine transform for the image (needed to compute extent)\n    - red_band, green_band, blue_band: indices for RGB bands\n    \"\"\"\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # ---- Plot RGB or Grayscale image from array ----\n    if image_data is not None:\n        num_bands = image_data.shape[0]\n        if rgb_bands and num_bands &gt;= 3:\n            r = image_data[rgb_bands[0]].astype(float)\n            g = image_data[rgb_bands[1]].astype(float)\n            b = image_data[rgb_bands[2]].astype(float)\n\n            r_norm = np.clip((r - r.min()) / (r.max() - r.min() + 1e-10), 0, 1)\n            g_norm = np.clip((g - g.min()) / (g.max() - g.min() + 1e-10), 0, 1)\n            b_norm = np.clip((b - b.min()) / (b.max() - b.min() + 1e-10), 0, 1)\n\n            rgb = np.stack([r_norm, g_norm, b_norm], axis=2)\n            if transform:\n                from rasterio.plot import plotting_extent\n\n                extent = plotting_extent(image_data[0], transform=transform)\n                ax.imshow(rgb, extent=extent)\n            else:\n                ax.imshow(rgb)\n        else:\n            gray = image_data[0]\n            gray_norm = (gray - gray.min()) / (gray.max() - gray.min() + 1e-10)\n            if transform:\n                from rasterio.plot import plotting_extent\n\n                extent = plotting_extent(gray, transform=transform)\n                ax.imshow(gray_norm, cmap=\"gray\", extent=extent)\n            else:\n                ax.imshow(gray_norm, cmap=\"gray\")\n\n    # ---- Plot classification overlay ----\n    gdf = layer.objects.copy()\n    if gdf.crs is None:\n        raise ValueError(\"GeoDataFrame has no CRS\")\n\n    if not class_color:\n        class_color = {}\n    if class_field not in gdf.columns:\n        raise ValueError(f\"Class field '{class_field}' not found\")\n\n    class_values = [v for v in gdf[class_field].unique() if v is not None]\n    base_colors = plt.cm.tab20(np.linspace(0, 1, max(len(class_values), 1)))\n    class_map = {}\n\n    for idx, class_value in enumerate(class_values):\n        if class_value in class_color:\n            color_hex = class_color[class_value]\n        else:\n            rgb_val = base_colors[idx % len(base_colors)][:3]\n            color_hex = \"#{:02x}{:02x}{:02x}\".format(int(rgb_val[0] * 255), int(rgb_val[1] * 255), int(rgb_val[2] * 255))\n            class_color[class_value] = color_hex\n        class_map[class_value] = color_hex\n\n    for class_value in class_values:\n        gdf[gdf[class_field] == class_value].plot(ax=ax, facecolor=class_map[class_value], edgecolor=\"black\", linewidth=0.5)\n\n    if legend:\n        handles = [mpatches.Patch(color=class_map[val], label=val) for val in class_values]\n        ax.legend(handles=handles, loc=\"upper right\", title=class_field)\n\n    ax.set_title(\"Sample Data Visualization\")\n    ax.set_axis_off()\n    return fig\n</code></pre>"},{"location":"examples/simple_usecase/","title":"nickyspatial Workflow Example","text":"In\u00a0[\u00a0]: Copied! <pre>! pip install nickyspatial\n</pre> ! pip install nickyspatial In\u00a0[\u00a0]: Copied! <pre>import os\nimport requests\nimport matplotlib.pyplot as plt\n\nfrom nickyspatial import (\n    LayerManager,\n    SlicSegmentation,\n    RuleSet,\n    attach_ndvi,\n    attach_shape_metrics,\n    attach_spectral_indices,\n    layer_to_raster,\n    layer_to_vector,\n    plot_classification,\n    plot_layer,\n    read_raster,\n)\n\noutput_dir = \"output\"\nos.makedirs(output_dir, exist_ok=True)\n\n\ndata_dir = \"data\"\nos.makedirs(data_dir, exist_ok=True)\n\nraster_path = os.path.join(data_dir, \"sample.tif\")\n\nif not os.path.exists(raster_path):\n    url = \"https://github.com/kshitijrajsharma/nickyspatial/raw/refs/heads/master/data/sample.tif\"\n    print(f\"Downloading sample raster from {url}...\")\n    response = requests.get(url)\n    response.raise_for_status()  # Ensure the download succeeded\n    with open(raster_path, \"wb\") as f:\n        f.write(response.content)\n    print(f\"Downloaded sample raster to {raster_path}\")\nelse:\n    print(f\"Using existing raster at: {raster_path}\")\n</pre> import os import requests import matplotlib.pyplot as plt  from nickyspatial import (     LayerManager,     SlicSegmentation,     RuleSet,     attach_ndvi,     attach_shape_metrics,     attach_spectral_indices,     layer_to_raster,     layer_to_vector,     plot_classification,     plot_layer,     read_raster, )  output_dir = \"output\" os.makedirs(output_dir, exist_ok=True)   data_dir = \"data\" os.makedirs(data_dir, exist_ok=True)  raster_path = os.path.join(data_dir, \"sample.tif\")  if not os.path.exists(raster_path):     url = \"https://github.com/kshitijrajsharma/nickyspatial/raw/refs/heads/master/data/sample.tif\"     print(f\"Downloading sample raster from {url}...\")     response = requests.get(url)     response.raise_for_status()  # Ensure the download succeeded     with open(raster_path, \"wb\") as f:         f.write(response.content)     print(f\"Downloaded sample raster to {raster_path}\") else:     print(f\"Using existing raster at: {raster_path}\") <pre>Using existing raster at: data/sample.tif\n</pre> In\u00a0[2]: Copied! <pre>image_data, transform, crs = read_raster(raster_path)\nprint(f\"Image dimensions: {image_data.shape}\")\nprint(f\"Coordinate system: {crs}\")\n</pre> image_data, transform, crs = read_raster(raster_path) print(f\"Image dimensions: {image_data.shape}\") print(f\"Coordinate system: {crs}\") <pre>Image dimensions: (4, 877, 1164)\nCoordinate system: EPSG:32654\n</pre> In\u00a0[\u00a0]: Copied! <pre>manager = LayerManager()\n\nsegmenter = SlicSegmentation(scale=40, compactness=1)\nsegmentation_layer = segmenter.execute(\n    image_data,\n    transform,\n    crs,\n    layer_manager=manager,\n    layer_name=\"Base_Segmentation\",\n)\n\nprint(\"Segmentation layer created:\")\nprint(segmentation_layer)\n</pre> manager = LayerManager()  segmenter = SlicSegmentation(scale=40, compactness=1) segmentation_layer = segmenter.execute(     image_data,     transform,     crs,     layer_manager=manager,     layer_name=\"Base_Segmentation\", )  print(\"Segmentation layer created:\") print(segmentation_layer) <pre>Number of segments: 638\nSegmentation layer created:\nLayer 'Base_Segmentation' (type: segmentation, parent: None, objects: 638)\n</pre> In\u00a0[4]: Copied! <pre>fig1 = plot_layer(segmentation_layer, image_data, rgb_bands=(3, 2, 1), show_boundaries=True)\nplt.show()\n\nfig1.savefig(os.path.join(output_dir, \"1_segmentation.png\"))\n</pre> fig1 = plot_layer(segmentation_layer, image_data, rgb_bands=(3, 2, 1), show_boundaries=True) plt.show()  fig1.savefig(os.path.join(output_dir, \"1_segmentation.png\")) In\u00a0[5]: Copied! <pre>segmentation_layer.attach_function(\n    attach_ndvi,\n    name=\"ndvi_stats\",\n    nir_column=\"band_4_mean\",\n    red_column=\"band_3_mean\",\n    output_column=\"NDVI\",\n)\n\nsegmentation_layer.attach_function(\n    attach_spectral_indices,\n    name=\"spectral_indices\",\n    bands={\n        \"blue\": \"band_1_mean\",\n        \"green\": \"band_2_mean\",\n        \"red\": \"band_3_mean\",\n        \"nir\": \"band_4_mean\",\n    },\n)\n\nfig2 = plot_layer(segmentation_layer, attribute=\"NDVI\", title=\"NDVI Values\", cmap=\"RdYlGn\")\nplt.show()\n\nfig2.savefig(os.path.join(output_dir, \"2_ndvi.png\"))\n</pre> segmentation_layer.attach_function(     attach_ndvi,     name=\"ndvi_stats\",     nir_column=\"band_4_mean\",     red_column=\"band_3_mean\",     output_column=\"NDVI\", )  segmentation_layer.attach_function(     attach_spectral_indices,     name=\"spectral_indices\",     bands={         \"blue\": \"band_1_mean\",         \"green\": \"band_2_mean\",         \"red\": \"band_3_mean\",         \"nir\": \"band_4_mean\",     }, )  fig2 = plot_layer(segmentation_layer, attribute=\"NDVI\", title=\"NDVI Values\", cmap=\"RdYlGn\") plt.show()  fig2.savefig(os.path.join(output_dir, \"2_ndvi.png\")) In\u00a0[6]: Copied! <pre>segmentation_layer.attach_function(attach_shape_metrics, name=\"shape_metrics\")\n\nseg_geojson_path = os.path.join(output_dir, \"segmentation.geojson\")\nlayer_to_vector(segmentation_layer, seg_geojson_path)\nprint(f\"Segmentation GeoJSON saved to {seg_geojson_path}\")\n</pre> segmentation_layer.attach_function(attach_shape_metrics, name=\"shape_metrics\")  seg_geojson_path = os.path.join(output_dir, \"segmentation.geojson\") layer_to_vector(segmentation_layer, seg_geojson_path) print(f\"Segmentation GeoJSON saved to {seg_geojson_path}\") <pre>Segmentation GeoJSON saved to output/segmentation.geojson\n</pre> In\u00a0[7]: Copied! <pre>land_cover_rules = RuleSet(name=\"Land_Cover\")\nland_cover_rules.add_rule(name=\"Vegetation\", condition=\"NDVI &gt; 0.2\")\nland_cover_rules.add_rule(name=\"Other\", condition=\"NDVI &lt;= 0.2\")\n\nland_cover_layer = land_cover_rules.execute(\n    segmentation_layer,\n    layer_manager=manager,\n    layer_name=\"Land_Cover\",\n)\n\nfig3 = plot_classification(land_cover_layer, class_field=\"classification\")\nplt.show()\n\nfig3.savefig(os.path.join(output_dir, \"3_land_cover.png\"))\n</pre> land_cover_rules = RuleSet(name=\"Land_Cover\") land_cover_rules.add_rule(name=\"Vegetation\", condition=\"NDVI &gt; 0.2\") land_cover_rules.add_rule(name=\"Other\", condition=\"NDVI &lt;= 0.2\")  land_cover_layer = land_cover_rules.execute(     segmentation_layer,     layer_manager=manager,     layer_name=\"Land_Cover\", )  fig3 = plot_classification(land_cover_layer, class_field=\"classification\") plt.show()  fig3.savefig(os.path.join(output_dir, \"3_land_cover.png\")) In\u00a0[8]: Copied! <pre>vegetation_rules = RuleSet(name=\"Vegetation_Types\")\nvegetation_rules.add_rule(\n    name=\"Healthy_Vegetation\",\n    condition=\"(classification == 'Vegetation') &amp; (NDVI &gt; 0.6)\",\n)\nvegetation_rules.add_rule(\n    name=\"Moderate_Vegetation\",\n    condition=\"(classification == 'Vegetation') &amp; (NDVI &lt;= 0.6) &amp; (NDVI &gt; 0.4)\",\n)\nvegetation_rules.add_rule(\n    name=\"Sparse_Vegetation\",\n    condition=\"(classification == 'Vegetation') &amp; (NDVI &lt;= 0.4)\",\n)\n\nvegetation_layer = vegetation_rules.execute(\n    land_cover_layer,\n    layer_manager=manager,\n    layer_name=\"Vegetation_Types\",\n    result_field=\"veg_class\",\n)\n\nfig4 = plot_classification(vegetation_layer, class_field=\"veg_class\")\nplt.show()\n\nfig4.savefig(os.path.join(output_dir, \"4_vegetation_types.png\"))\n</pre> vegetation_rules = RuleSet(name=\"Vegetation_Types\") vegetation_rules.add_rule(     name=\"Healthy_Vegetation\",     condition=\"(classification == 'Vegetation') &amp; (NDVI &gt; 0.6)\", ) vegetation_rules.add_rule(     name=\"Moderate_Vegetation\",     condition=\"(classification == 'Vegetation') &amp; (NDVI &lt;= 0.6) &amp; (NDVI &gt; 0.4)\", ) vegetation_rules.add_rule(     name=\"Sparse_Vegetation\",     condition=\"(classification == 'Vegetation') &amp; (NDVI &lt;= 0.4)\", )  vegetation_layer = vegetation_rules.execute(     land_cover_layer,     layer_manager=manager,     layer_name=\"Vegetation_Types\",     result_field=\"veg_class\", )  fig4 = plot_classification(vegetation_layer, class_field=\"veg_class\") plt.show()  fig4.savefig(os.path.join(output_dir, \"4_vegetation_types.png\")) In\u00a0[9]: Copied! <pre>land_cover_geojson = os.path.join(output_dir, \"land_cover.geojson\")\nvegetation_geojson = os.path.join(output_dir, \"vegetation_types.geojson\")\n\nlayer_to_vector(land_cover_layer, land_cover_geojson)\nlayer_to_vector(vegetation_layer, vegetation_geojson)\n\nland_cover_raster = os.path.join(output_dir, \"land_cover.tif\")\nlayer_to_raster(land_cover_layer, land_cover_raster, column=\"classification\")\n\nprint(f\"Land cover GeoJSON saved to {land_cover_geojson}\")\nprint(f\"Vegetation GeoJSON saved to {vegetation_geojson}\")\nprint(f\"Land cover raster saved to {land_cover_raster}\")\n\n# List all available layers from the manager\nprint(\"\\nAvailable layers:\")\nfor i, layer_name in enumerate(manager.get_layer_names(), start=1):\n    print(f\"  {i}. {layer_name}\")\n</pre> land_cover_geojson = os.path.join(output_dir, \"land_cover.geojson\") vegetation_geojson = os.path.join(output_dir, \"vegetation_types.geojson\")  layer_to_vector(land_cover_layer, land_cover_geojson) layer_to_vector(vegetation_layer, vegetation_geojson)  land_cover_raster = os.path.join(output_dir, \"land_cover.tif\") layer_to_raster(land_cover_layer, land_cover_raster, column=\"classification\")  print(f\"Land cover GeoJSON saved to {land_cover_geojson}\") print(f\"Vegetation GeoJSON saved to {vegetation_geojson}\") print(f\"Land cover raster saved to {land_cover_raster}\")  # List all available layers from the manager print(\"\\nAvailable layers:\") for i, layer_name in enumerate(manager.get_layer_names(), start=1):     print(f\"  {i}. {layer_name}\") <pre>Mapping categorical values: {'Vegetation': 0, 'Other': 1}\nLand cover GeoJSON saved to output/land_cover.geojson\nVegetation GeoJSON saved to output/vegetation_types.geojson\nLand cover raster saved to output/land_cover.tif\n\nAvailable layers:\n  1. Base_Segmentation\n  2. Land_Cover\n  3. Vegetation_Types\n</pre>"},{"location":"examples/simple_usecase/#nickyspatial-workflow-example","title":"nickyspatial Workflow Example\u00b6","text":"<p>In this notebook we demonstrate how to use the <code>nickyspatial</code> library to read a raster, perform segmentation, calculate spectral indices (like NDVI), and apply rule-based classification. We then display the resulting figures inline. This example explains how rules are applied to classify segments.</p>"},{"location":"examples/simple_usecase/#setup-imports","title":"Setup &amp; Imports\u00b6","text":"<p>We begin by importing the required modules and setting up the environment. &amp; Download the sample quickbird satellite image for our module</p>"},{"location":"examples/simple_usecase/#reading-the-raster","title":"Reading the Raster\u00b6","text":"<p>We now read the raster data and print some basic information about the image.</p>"},{"location":"examples/simple_usecase/#performing-segmentation","title":"Performing Segmentation\u00b6","text":"<p>Here we perform multi-resolution segmentation. A <code>LayerManager</code> is used to keep track of all layers created in the process. nickyspatial packages uses a layer object which is an underlying vector segmentation tied up to the raster , similar concept as layer in ecognition</p>"},{"location":"examples/simple_usecase/#visualizing-segmentation","title":"Visualizing Segmentation\u00b6","text":"<p>We utilize the built-in plotting function to visualize the segmentation. The image will be displayed inline.</p>"},{"location":"examples/simple_usecase/#calculating-spectral-indices-ndvi","title":"Calculating Spectral Indices (NDVI)\u00b6","text":"<p>Next, we attach functions to the segmentation layer to calculate NDVI and other spectral indices. NDVI is a common metric to assess vegetation health. Here we are doing an example how to use the existing pre-defined rules in the library</p>"},{"location":"examples/simple_usecase/#calculating-shape-metrics","title":"Calculating Shape Metrics\u00b6","text":"<p>In this step, we attach a function to calculate shape index of objects and export the segmentation results as a GeoJSON file.</p>"},{"location":"examples/simple_usecase/#applying-land-cover-classification-rules","title":"Applying Land Cover Classification Rules\u00b6","text":"<p>Now we demonstrate how to use rule-based classification. Rules are defined for the land cover classification. For example, we can define a rule that marks segments as <code>Vegetation</code> if their NDVI is greater than 0.2; all other segments are marked as <code>Other</code>. With this technique we define our custom rule which can be in hierarchical order We then generate a classified layer and visualize the results.</p>"},{"location":"examples/simple_usecase/#applying-hierarchical-classification-rules","title":"Applying Hierarchical Classification Rules\u00b6","text":"<p>For further refinement, we can apply hierarchical rules. In this example, we subdivide the <code>Vegetation</code> class into categories such as <code>Healthy_Vegetation</code>, <code>Moderate_Vegetation</code>, and <code>Sparse_Vegetation</code> based on NDVI thresholds.</p> <p>This demonstrates how you can build upon basic classifications to obtain more granular information.</p>"},{"location":"examples/simple_usecase/#exporting-and-reviewing-results","title":"Exporting and Reviewing Results\u00b6","text":"<p>Finally we export the land cover and vegetation layers as GeoJSON and raster, and print out the available layers from the manager.</p>"},{"location":"examples/simple_usecase/#summary","title":"Summary\u00b6","text":"<p>In this notebook we:</p> <ul> <li>Loaded a sample raster image.</li> <li>Performed segmentation on the raster.</li> <li>Calculated spectral indices (NDVI) and attached additional functions.</li> <li>Applied basic and hierarchical rule-based classifications to derive land cover types.</li> <li>Displayed the figures inline and exported the results for further analysis.</li> </ul> <p>This example demonstrates how rule-based functions can be integrated for remote sensing and image analysis workflows using the nickyspatial library.</p>"},{"location":"examples/supervised_classification/","title":"Supervised classification Workflow Example","text":"In\u00a0[1]: Copied! <pre>! pip install nickyspatial\n</pre> ! pip install nickyspatial <pre>Requirement already satisfied: nickyspatial in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (0.1.1)\nRequirement already satisfied: folium&gt;=0.19.5 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (0.19.5)\nRequirement already satisfied: geopandas&gt;=1.0.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (1.0.1)\nRequirement already satisfied: ipympl&gt;=0.9.7 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (0.9.7)\nRequirement already satisfied: ipywidgets&gt;=8.1.7 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (8.1.7)\nRequirement already satisfied: matplotlib&gt;=3.10.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (3.10.3)\nRequirement already satisfied: numexpr&gt;=2.10.2 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (2.10.2)\nRequirement already satisfied: pandas&gt;=2.2.3 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (2.2.3)\nRequirement already satisfied: plotly&gt;=6.0.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (6.0.1)\nRequirement already satisfied: rasterio&gt;=1.4.3 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (1.4.3)\nRequirement already satisfied: scikit-image&gt;=0.25.2 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (0.25.2)\nRequirement already satisfied: scikit-learn&gt;=1.6.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (1.6.1)\nRequirement already satisfied: scipy&gt;=1.15.2 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (1.15.3)\nRequirement already satisfied: seaborn&gt;=0.13.2 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (0.13.2)\nRequirement already satisfied: streamlit-folium&gt;=0.24.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from nickyspatial) (0.25.0)\nRequirement already satisfied: branca&gt;=0.6.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from folium&gt;=0.19.5-&gt;nickyspatial) (0.8.1)\nRequirement already satisfied: jinja2&gt;=2.9 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from folium&gt;=0.19.5-&gt;nickyspatial) (3.1.5)\nRequirement already satisfied: numpy in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from folium&gt;=0.19.5-&gt;nickyspatial) (1.24.4)\nRequirement already satisfied: requests in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from folium&gt;=0.19.5-&gt;nickyspatial) (2.32.3)\nRequirement already satisfied: xyzservices in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from folium&gt;=0.19.5-&gt;nickyspatial) (2025.4.0)\nRequirement already satisfied: pyogrio&gt;=0.7.2 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from geopandas&gt;=1.0.1-&gt;nickyspatial) (0.11.0)\nRequirement already satisfied: packaging in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from geopandas&gt;=1.0.1-&gt;nickyspatial) (24.2)\nRequirement already satisfied: pyproj&gt;=3.3.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from geopandas&gt;=1.0.1-&gt;nickyspatial) (3.7.1)\nRequirement already satisfied: shapely&gt;=2.0.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from geopandas&gt;=1.0.1-&gt;nickyspatial) (2.1.0)\nRequirement already satisfied: ipython&lt;10 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipympl&gt;=0.9.7-&gt;nickyspatial) (8.30.0)\nRequirement already satisfied: pillow in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipympl&gt;=0.9.7-&gt;nickyspatial) (11.0.0)\nRequirement already satisfied: traitlets&lt;6 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipympl&gt;=0.9.7-&gt;nickyspatial) (5.14.3)\nRequirement already satisfied: comm&gt;=0.1.3 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipywidgets&gt;=8.1.7-&gt;nickyspatial) (0.2.2)\nRequirement already satisfied: widgetsnbextension~=4.0.14 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipywidgets&gt;=8.1.7-&gt;nickyspatial) (4.0.14)\nRequirement already satisfied: jupyterlab_widgets~=3.0.15 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipywidgets&gt;=8.1.7-&gt;nickyspatial) (3.0.15)\nRequirement already satisfied: contourpy&gt;=1.0.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from matplotlib&gt;=3.10.1-&gt;nickyspatial) (1.3.1)\nRequirement already satisfied: cycler&gt;=0.10 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from matplotlib&gt;=3.10.1-&gt;nickyspatial) (0.12.1)\nRequirement already satisfied: fonttools&gt;=4.22.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from matplotlib&gt;=3.10.1-&gt;nickyspatial) (4.55.3)\nRequirement already satisfied: kiwisolver&gt;=1.3.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from matplotlib&gt;=3.10.1-&gt;nickyspatial) (1.4.7)\nRequirement already satisfied: pyparsing&gt;=2.3.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from matplotlib&gt;=3.10.1-&gt;nickyspatial) (3.2.0)\nRequirement already satisfied: python-dateutil&gt;=2.7 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from matplotlib&gt;=3.10.1-&gt;nickyspatial) (2.9.0.post0)\nRequirement already satisfied: pytz&gt;=2020.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from pandas&gt;=2.2.3-&gt;nickyspatial) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from pandas&gt;=2.2.3-&gt;nickyspatial) (2023.3)\nRequirement already satisfied: narwhals&gt;=1.15.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from plotly&gt;=6.0.1-&gt;nickyspatial) (1.39.0)\nRequirement already satisfied: affine in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from rasterio&gt;=1.4.3-&gt;nickyspatial) (2.4.0)\nRequirement already satisfied: attrs in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from rasterio&gt;=1.4.3-&gt;nickyspatial) (24.3.0)\nRequirement already satisfied: certifi in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from rasterio&gt;=1.4.3-&gt;nickyspatial) (2025.1.31)\nRequirement already satisfied: click&gt;=4.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from rasterio&gt;=1.4.3-&gt;nickyspatial) (8.1.7)\nRequirement already satisfied: cligj&gt;=0.5 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from rasterio&gt;=1.4.3-&gt;nickyspatial) (0.7.2)\nRequirement already satisfied: click-plugins in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from rasterio&gt;=1.4.3-&gt;nickyspatial) (1.1.1)\nRequirement already satisfied: networkx&gt;=3.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from scikit-image&gt;=0.25.2-&gt;nickyspatial) (3.4.2)\nRequirement already satisfied: imageio!=2.35.0,&gt;=2.33 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from scikit-image&gt;=0.25.2-&gt;nickyspatial) (2.36.1)\nRequirement already satisfied: tifffile&gt;=2022.8.12 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from scikit-image&gt;=0.25.2-&gt;nickyspatial) (2024.12.12)\nRequirement already satisfied: lazy-loader&gt;=0.4 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from scikit-image&gt;=0.25.2-&gt;nickyspatial) (0.4)\nRequirement already satisfied: joblib&gt;=1.2.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from scikit-learn&gt;=1.6.1-&gt;nickyspatial) (1.4.2)\nRequirement already satisfied: threadpoolctl&gt;=3.1.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from scikit-learn&gt;=1.6.1-&gt;nickyspatial) (3.5.0)\nRequirement already satisfied: streamlit&gt;=1.35.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (1.45.1)\nRequirement already satisfied: decorator in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (5.1.1)\nRequirement already satisfied: exceptiongroup in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (1.2.2)\nRequirement already satisfied: jedi&gt;=0.16 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (0.19.2)\nRequirement already satisfied: matplotlib-inline in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (0.1.7)\nRequirement already satisfied: pexpect&gt;4.3 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (4.9.0)\nRequirement already satisfied: prompt_toolkit&lt;3.1.0,&gt;=3.0.41 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (3.0.48)\nRequirement already satisfied: pygments&gt;=2.4.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (2.18.0)\nRequirement already satisfied: stack_data in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (0.6.3)\nRequirement already satisfied: typing_extensions&gt;=4.6 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (4.12.2)\nRequirement already satisfied: MarkupSafe&gt;=2.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from jinja2&gt;=2.9-&gt;folium&gt;=0.19.5-&gt;nickyspatial) (3.0.2)\nRequirement already satisfied: six&gt;=1.5 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib&gt;=3.10.1-&gt;nickyspatial) (1.17.0)\nRequirement already satisfied: altair&lt;6,&gt;=4.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (5.5.0)\nRequirement already satisfied: blinker&lt;2,&gt;=1.5.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (1.9.0)\nRequirement already satisfied: cachetools&lt;6,&gt;=4.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (5.5.2)\nRequirement already satisfied: protobuf&lt;7,&gt;=3.20 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (6.30.2)\nRequirement already satisfied: pyarrow&gt;=7.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (20.0.0)\nRequirement already satisfied: tenacity&lt;10,&gt;=8.1.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (9.1.2)\nRequirement already satisfied: toml&lt;2,&gt;=0.10.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (0.10.2)\nRequirement already satisfied: gitpython!=3.1.19,&lt;4,&gt;=3.0.7 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (3.1.44)\nRequirement already satisfied: pydeck&lt;1,&gt;=0.8.0b4 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (0.9.1)\nRequirement already satisfied: tornado&lt;7,&gt;=6.0.3 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (6.4.2)\nRequirement already satisfied: charset_normalizer&lt;4,&gt;=2 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from requests-&gt;folium&gt;=0.19.5-&gt;nickyspatial) (3.4.1)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from requests-&gt;folium&gt;=0.19.5-&gt;nickyspatial) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from requests-&gt;folium&gt;=0.19.5-&gt;nickyspatial) (2.3.0)\nRequirement already satisfied: jsonschema&gt;=3.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from altair&lt;6,&gt;=4.0-&gt;streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (4.23.0)\nRequirement already satisfied: gitdb&lt;5,&gt;=4.0.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from gitpython!=3.1.19,&lt;4,&gt;=3.0.7-&gt;streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (4.0.12)\nRequirement already satisfied: parso&lt;0.9.0,&gt;=0.8.4 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from jedi&gt;=0.16-&gt;ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (0.8.4)\nRequirement already satisfied: ptyprocess&gt;=0.5 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from pexpect&gt;4.3-&gt;ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (0.7.0)\nRequirement already satisfied: wcwidth in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from prompt_toolkit&lt;3.1.0,&gt;=3.0.41-&gt;ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (0.2.13)\nRequirement already satisfied: executing&gt;=1.2.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from stack_data-&gt;ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (2.1.0)\nRequirement already satisfied: asttokens&gt;=2.1.0 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from stack_data-&gt;ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (3.0.0)\nRequirement already satisfied: pure_eval in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from stack_data-&gt;ipython&lt;10-&gt;ipympl&gt;=0.9.7-&gt;nickyspatial) (0.2.3)\nRequirement already satisfied: smmap&lt;6,&gt;=3.0.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from gitdb&lt;5,&gt;=4.0.1-&gt;gitpython!=3.1.19,&lt;4,&gt;=3.0.7-&gt;streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (5.0.2)\nRequirement already satisfied: jsonschema-specifications&gt;=2023.03.6 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from jsonschema&gt;=3.0-&gt;altair&lt;6,&gt;=4.0-&gt;streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (2024.10.1)\nRequirement already satisfied: referencing&gt;=0.28.4 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from jsonschema&gt;=3.0-&gt;altair&lt;6,&gt;=4.0-&gt;streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (0.35.1)\nRequirement already satisfied: rpds-py&gt;=0.7.1 in /Users/rabinatwayana/Rabina/anaconda3/envs/obia/lib/python3.10/site-packages (from jsonschema&gt;=3.0-&gt;altair&lt;6,&gt;=4.0-&gt;streamlit&gt;=1.35.0-&gt;streamlit-folium&gt;=0.24.1-&gt;nickyspatial) (0.22.3)\n</pre> In\u00a0[\u00a0]: Copied! <pre>import os\nimport requests\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nfrom nickyspatial import (\n    LayerManager,\n    SlicSegmentation,\n    RuleSet,\n    attach_ndvi,\n    attach_shape_metrics,\n    attach_spectral_indices,\n    layer_to_raster,\n    layer_to_vector,\n    plot_classification,\n    plot_sample,\n    plot_layer,\n    plot_layer_interactive,\n    read_raster,\n    plot_layer_interactive_plotly,\n    MergeRuleSet,\n    EnclosedByRuleSet,\n    TouchedByRuleSet,\n    SupervisedClassifier,\n    Layer  \n)\n\noutput_dir = \"output\"\nos.makedirs(output_dir, exist_ok=True)\n\n\ndata_dir = \"data\"\nos.makedirs(data_dir, exist_ok=True)\n\nraster_path = os.path.join(data_dir, \"sample.tif\")\n\n\nif not os.path.exists(raster_path):\n    url = \"https://github.com/kshitijrajsharma/nickyspatial/raw/refs/heads/master/data/sample.tif\"\n    print(f\"Downloading sample raster from {url}...\")\n    response = requests.get(url)\n    response.raise_for_status()  # Ensure the download succeeded\n    with open(raster_path, \"wb\") as f:\n        f.write(response.content)\n    print(f\"Downloaded sample raster to {raster_path}\")\nelse:\n    print(f\"Using existing raster at: {raster_path}\")\n</pre> import os import requests import matplotlib.pyplot as plt import pandas as pd  from nickyspatial import (     LayerManager,     SlicSegmentation,     RuleSet,     attach_ndvi,     attach_shape_metrics,     attach_spectral_indices,     layer_to_raster,     layer_to_vector,     plot_classification,     plot_sample,     plot_layer,     plot_layer_interactive,     read_raster,     plot_layer_interactive_plotly,     MergeRuleSet,     EnclosedByRuleSet,     TouchedByRuleSet,     SupervisedClassifier,     Layer   )  output_dir = \"output\" os.makedirs(output_dir, exist_ok=True)   data_dir = \"data\" os.makedirs(data_dir, exist_ok=True)  raster_path = os.path.join(data_dir, \"sample.tif\")   if not os.path.exists(raster_path):     url = \"https://github.com/kshitijrajsharma/nickyspatial/raw/refs/heads/master/data/sample.tif\"     print(f\"Downloading sample raster from {url}...\")     response = requests.get(url)     response.raise_for_status()  # Ensure the download succeeded     with open(raster_path, \"wb\") as f:         f.write(response.content)     print(f\"Downloaded sample raster to {raster_path}\") else:     print(f\"Using existing raster at: {raster_path}\") <pre>Using existing raster at: data/sample.tif\n</pre> In\u00a0[3]: Copied! <pre>image_data, transform, crs = read_raster(raster_path)\nprint(f\"Image dimensions: {image_data.shape}\")\nprint(f\"Coordinate system: {crs}\")\n</pre> image_data, transform, crs = read_raster(raster_path) print(f\"Image dimensions: {image_data.shape}\") print(f\"Coordinate system: {crs}\") <pre>Image dimensions: (4, 877, 1164)\nCoordinate system: EPSG:32654\n</pre> In\u00a0[\u00a0]: Copied! <pre>manager = LayerManager()\n\nsegmenter = SlicSegmentation(scale=20, compactness=0.50)\nsegmentation_layer = segmenter.execute(\n    image_data,\n    transform,\n    crs,\n    layer_manager=manager,\n    layer_name=\"Base_Segmentation\",\n)\n\nprint(\"Segmentation layer created:\")\nprint(segmentation_layer)\n</pre> manager = LayerManager()  segmenter = SlicSegmentation(scale=20, compactness=0.50) segmentation_layer = segmenter.execute(     image_data,     transform,     crs,     layer_manager=manager,     layer_name=\"Base_Segmentation\", )  print(\"Segmentation layer created:\") print(segmentation_layer) <pre>Number of segments: 2552\nSegmentation layer created:\nLayer 'Base_Segmentation' (type: segmentation, parent: None, objects: 2543)\n</pre> In\u00a0[5]: Copied! <pre># plt.close(\"all\")\n# %matplotlib inline\nfig1 = plot_layer(layer=segmentation_layer, image_data=image_data, rgb_bands=(3, 2, 1), show_boundaries=True, figsize=(10,8))\nplt.show()\n\nfig1.savefig(os.path.join(output_dir, \"1_segmentation.png\"))\n</pre> # plt.close(\"all\") # %matplotlib inline fig1 = plot_layer(layer=segmentation_layer, image_data=image_data, rgb_bands=(3, 2, 1), show_boundaries=True, figsize=(10,8)) plt.show()  fig1.savefig(os.path.join(output_dir, \"1_segmentation.png\")) In\u00a0[6]: Copied! <pre>segmentation_layer.attach_function(\n    attach_ndvi,\n    name=\"ndvi_stats\",\n    nir_column=\"band_4_mean\",\n    red_column=\"band_3_mean\",\n    output_column=\"NDVI\",\n)\nsegmentation_layer.attach_function(attach_shape_metrics, name=\"shape_metrics\")\n</pre> segmentation_layer.attach_function(     attach_ndvi,     name=\"ndvi_stats\",     nir_column=\"band_4_mean\",     red_column=\"band_3_mean\",     output_column=\"NDVI\", ) segmentation_layer.attach_function(attach_shape_metrics, name=\"shape_metrics\") Out[6]: <pre>&lt;nickyspatial.core.layer.Layer at 0x150bfbf70&gt;</pre> In\u00a0[7]: Copied! <pre>plot_layer_interactive_plotly(segmentation_layer, image_data, rgb_bands=(3,2,1), show_boundaries=True, figsize=(900,600))\n</pre> plot_layer_interactive_plotly(segmentation_layer, image_data, rgb_bands=(3,2,1), show_boundaries=True, figsize=(900,600)) In\u00a0[\u00a0]: Copied! <pre># Sample Data for Classification\n# This section defines the sample data used for classification. \n# Each class is assigned with a list of segment IDs and a specific color for visualization.\nsamples={\n    \"Water\": [102,384,659,1142,1662,1710,2113,2182,2481,1024],\n    \"Builtup\": [467,1102,1431,1984,1227,1736,774,1065],\n    \"Vegetation\": [832,1778,2035,1417,1263,242,2049,2397],\n}\n\nclasses_color= {\n    \"Water\": \"#3437c2\",\n    \"Builtup\":\"#de1421\",\n    \"Vegetation\": \"#0f6b2f\"\n}\n</pre> # Sample Data for Classification # This section defines the sample data used for classification.  # Each class is assigned with a list of segment IDs and a specific color for visualization. samples={     \"Water\": [102,384,659,1142,1662,1710,2113,2182,2481,1024],     \"Builtup\": [467,1102,1431,1984,1227,1736,774,1065],     \"Vegetation\": [832,1778,2035,1417,1263,242,2049,2397], }  classes_color= {     \"Water\": \"#3437c2\",     \"Builtup\":\"#de1421\",     \"Vegetation\": \"#0f6b2f\" }   In\u00a0[9]: Copied! <pre>sample_objects = segmentation_layer.objects.copy()\nsample_objects[\"classification\"] = None\n\nfor class_name in samples.keys():\n    sample_objects.loc[sample_objects[\"segment_id\"].isin(samples[class_name]), \"classification\"] = class_name\n\n# Step 3: Wrap the modified GeoDataFrame back into a Layer\nsample_layer = Layer(name=\"Sample Classification\", type=\"classification\")\nsample_layer.objects = sample_objects\n\nfig = plot_sample(\n    sample_layer,\n    image_data=image_data,          \n    rgb_bands=(3,2,1),\n    transform=transform,          \n    class_field=\"classification\",\n    class_color=classes_color,\n    figsize=(10,8)\n\n)\nplt.show()\n</pre> sample_objects = segmentation_layer.objects.copy() sample_objects[\"classification\"] = None  for class_name in samples.keys():     sample_objects.loc[sample_objects[\"segment_id\"].isin(samples[class_name]), \"classification\"] = class_name  # Step 3: Wrap the modified GeoDataFrame back into a Layer sample_layer = Layer(name=\"Sample Classification\", type=\"classification\") sample_layer.objects = sample_objects  fig = plot_sample(     sample_layer,     image_data=image_data,               rgb_bands=(3,2,1),     transform=transform,               class_field=\"classification\",     class_color=classes_color,     figsize=(10,8)  ) plt.show() In\u00a0[\u00a0]: Copied! <pre># To get the columns/features name if the segmenatation layer. \n# This is useful to define the features list in the following supervised classification task\nsegmentation_layer.objects.columns\n</pre> # To get the columns/features name if the segmenatation layer.  # This is useful to define the features list in the following supervised classification task segmentation_layer.objects.columns Out[\u00a0]: <pre>Index(['segment_id', 'area_pixels', 'area_units', 'geometry', 'band_1_mean',\n       'band_1_std', 'band_1_min', 'band_1_max', 'band_1_median',\n       'band_2_mean', 'band_2_std', 'band_2_min', 'band_2_max',\n       'band_2_median', 'band_3_mean', 'band_3_std', 'band_3_min',\n       'band_3_max', 'band_3_median', 'band_4_mean', 'band_4_std',\n       'band_4_min', 'band_4_max', 'band_4_median', 'NDVI', 'perimeter',\n       'shape_index', 'compactness'],\n      dtype='object')</pre> In\u00a0[\u00a0]: Copied! <pre># Parameters for defining Random Forest Classifier\n# Source: https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html\nparams={\"n_estimators\":100, \n        \"oob_score\":True, \n        \"random_state\":42,\n        }\n# Define features based on which classifier performs the classification\nfeatures=['band_1_mean','band_1_std', 'band_2_mean', 'band_2_std', 'band_3_mean', 'band_3_std',  'band_4_mean', 'band_4_std','NDVI']\n\n# Define supervised classifier and execute it\nRF_classification=SupervisedClassifier(name=\"RF Classification\", classifier_type=\"Random Forest\", classifier_params=params)\nRF_classification_layer, accuracy, feature_importances = RF_classification.execute(segmentation_layer,samples=samples,layer_manager=manager,layer_name=\"RF Classification\",features=features)\nprint(\"OOB SCORE\",accuracy)\n\n# Plot classification result\nfig4 = plot_classification(RF_classification_layer, class_field=\"classification\", class_color=classes_color,figsize=(10,8))\n\n# Plot feature importance graph\nig, ax = plt.subplots(figsize=(6, 4))\nfeature_importances.plot.bar(ax=ax)\nax.set_title(\"Importances\")\nax.set_xlabel(\"Features\")\nax.set_ylabel(\"Importance (%)\")\nplt.tight_layout()\nplt.show()\n</pre> # Parameters for defining Random Forest Classifier # Source: https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html params={\"n_estimators\":100,          \"oob_score\":True,          \"random_state\":42,         } # Define features based on which classifier performs the classification features=['band_1_mean','band_1_std', 'band_2_mean', 'band_2_std', 'band_3_mean', 'band_3_std',  'band_4_mean', 'band_4_std','NDVI']  # Define supervised classifier and execute it RF_classification=SupervisedClassifier(name=\"RF Classification\", classifier_type=\"Random Forest\", classifier_params=params) RF_classification_layer, accuracy, feature_importances = RF_classification.execute(segmentation_layer,samples=samples,layer_manager=manager,layer_name=\"RF Classification\",features=features) print(\"OOB SCORE\",accuracy)  # Plot classification result fig4 = plot_classification(RF_classification_layer, class_field=\"classification\", class_color=classes_color,figsize=(10,8))  # Plot feature importance graph ig, ax = plt.subplots(figsize=(6, 4)) feature_importances.plot.bar(ax=ax) ax.set_title(\"Importances\") ax.set_xlabel(\"Features\") ax.set_ylabel(\"Importance (%)\") plt.tight_layout() plt.show()  <pre>OOB SCORE 1.0\n</pre> In\u00a0[12]: Copied! <pre>merger = MergeRuleSet(\"Merge Segmentation\")\nclass_value=[\"Water\",\"Vegetation\"]\nmerged_layer = merger.execute(\n    source_layer=RF_classification_layer,\n    class_column_name=\"classification\",\n    class_value=class_value,\n    layer_manager=manager,\n    layer_name=\"Merged RF Classification\",\n)\nfig4 = plot_classification(merged_layer, class_field=\"classification\", class_color=classes_color,figsize=(10,8))\n</pre> merger = MergeRuleSet(\"Merge Segmentation\") class_value=[\"Water\",\"Vegetation\"] merged_layer = merger.execute(     source_layer=RF_classification_layer,     class_column_name=\"classification\",     class_value=class_value,     layer_manager=manager,     layer_name=\"Merged RF Classification\", ) fig4 = plot_classification(merged_layer, class_field=\"classification\", class_color=classes_color,figsize=(10,8))  In\u00a0[13]: Copied! <pre>enclosed_by_rule = EnclosedByRuleSet()\nenclosed_by_layer = enclosed_by_rule.execute(\n    source_layer=merged_layer,\n    class_column_name=\"classification\",\n    class_value_a=\"Vegetation\",\n    class_value_b=\"Builtup\",\n    new_class_name=\"Urban Vegetation\",\n    layer_manager=manager,\n    layer_name=\"enclosed_by_layer\",\n)\nclasses_color[\"Urban Vegetation\"]=\"#84f547\"\nfig4 = plot_classification(enclosed_by_layer, class_field=\"classification\", class_color=classes_color)\n</pre> enclosed_by_rule = EnclosedByRuleSet() enclosed_by_layer = enclosed_by_rule.execute(     source_layer=merged_layer,     class_column_name=\"classification\",     class_value_a=\"Vegetation\",     class_value_b=\"Builtup\",     new_class_name=\"Urban Vegetation\",     layer_manager=manager,     layer_name=\"enclosed_by_layer\", ) classes_color[\"Urban Vegetation\"]=\"#84f547\" fig4 = plot_classification(enclosed_by_layer, class_field=\"classification\", class_color=classes_color) In\u00a0[14]: Copied! <pre>touched_by_rule = TouchedByRuleSet()\ntouched_by_layer = touched_by_rule.execute(\n    source_layer=enclosed_by_layer,\n    class_column_name=\"classification\",\n    class_value_a=\"Builtup\",\n    class_value_b=\"Water\",\n    new_class_name=\"Builtup near WaterBodies\",\n    layer_manager=manager,\n    layer_name=\"touched_by_layer\",\n)\nclasses_color[\"Builtup near WaterBodies\"]=\"#1df0e2\"\nfig4 = plot_classification(touched_by_layer, class_field=\"classification\", class_color=classes_color)\n</pre> touched_by_rule = TouchedByRuleSet() touched_by_layer = touched_by_rule.execute(     source_layer=enclosed_by_layer,     class_column_name=\"classification\",     class_value_a=\"Builtup\",     class_value_b=\"Water\",     new_class_name=\"Builtup near WaterBodies\",     layer_manager=manager,     layer_name=\"touched_by_layer\", ) classes_color[\"Builtup near WaterBodies\"]=\"#1df0e2\" fig4 = plot_classification(touched_by_layer, class_field=\"classification\", class_color=classes_color) In\u00a0[\u00a0]: Copied! <pre># Applying merge rule to generate the final merged segments\nmerge_rule = MergeRuleSet(\"MergeByVegAndType\")\nmerged_layer2 = merger.execute(\n    source_layer=touched_by_layer,\n    class_column_name=\"classification\",\n    class_value=[\"Builtup near WaterBodies\",\"Builtup\"],\n    layer_manager=manager,\n    layer_name=\"Merged RF Classification 2\",\n)\nfig4 = plot_classification(merged_layer2, class_field=\"classification\", class_color=classes_color)\n</pre> # Applying merge rule to generate the final merged segments merge_rule = MergeRuleSet(\"MergeByVegAndType\") merged_layer2 = merger.execute(     source_layer=touched_by_layer,     class_column_name=\"classification\",     class_value=[\"Builtup near WaterBodies\",\"Builtup\"],     layer_manager=manager,     layer_name=\"Merged RF Classification 2\", ) fig4 = plot_classification(merged_layer2, class_field=\"classification\", class_color=classes_color)"},{"location":"examples/supervised_classification/#supervised-classification-workflow-example","title":"Supervised classification Workflow Example\u00b6","text":"<p>This example explains how to perform supervised classification.</p>"},{"location":"examples/supervised_classification/#setup-imports","title":"Setup &amp; Imports\u00b6","text":"<p>We begin by importing the required modules and setting up the environment. &amp; Download the sample quickbird satellite image for our module</p>"},{"location":"examples/supervised_classification/#summary","title":"Summary\u00b6","text":"<p>In this notebook we will perform following steps</p> <ul> <li>Load a sample raster image.</li> <li>Perform segmentation on the raster.</li> <li>Add NDVI feature.</li> <li>Define classes and sample collection</li> <li>Apply supervised classification using Random Forest Classifier</li> <li>Explore additional funtions: Merge_regions, Enclosed_by, Touched_by</li> </ul>"},{"location":"examples/supervised_classification/#reading-the-raster","title":"Reading the Raster\u00b6","text":"<p>We now read the raster data and print some basic information about the image.</p>"},{"location":"examples/supervised_classification/#performing-segmentation","title":"Performing Segmentation\u00b6","text":"<p>Here we perform multi-resolution segmentation. A <code>LayerManager</code> is used to keep track of all layers created in the process. nickyspatial packages uses a layer object which is an underlying vector segmentation tied up to the raster , similar concept as layer in ecognition</p>"},{"location":"examples/supervised_classification/#visualizing-segmentation","title":"Visualizing Segmentation\u00b6","text":"<p>We utilize the built-in plotting function to visualize the segmentation. The image will be displayed inline.</p>"},{"location":"examples/supervised_classification/#adding-ndvi-feature","title":"Adding NDVI feature\u00b6","text":""},{"location":"examples/supervised_classification/#sample-data-collection","title":"Sample data collection\u00b6","text":"<p>Using plotly package, interactive map is plotted to collect the segments_id(sample) for supervised classification.</p> <p>Just Hover the mouse in the map, segment_id will be displayed.</p>"},{"location":"examples/supervised_classification/#sample-data-visualization","title":"Sample Data Visualization\u00b6","text":"<p>In this steps, defined sample segment is visualized.</p>"},{"location":"examples/supervised_classification/#supervised-classification-using-random-forest-classifier","title":"Supervised Classification using Random Forest Classifier\u00b6","text":"<p>In this step, we will define and execute the supervised classification.</p>"},{"location":"examples/supervised_classification/#applying-merge-rule","title":"Applying merge rule\u00b6","text":"<p>In this step we will further refine the classification. In this example, we will merge region based on class value i.e. merge adjacent segments if they share the same class label.</p>"},{"location":"examples/supervised_classification/#applying-enclosed_by-rule","title":"Applying Enclosed_by rule\u00b6","text":"<p>This rule is also applied based on class label. This function determine whether a object/segment is completely contained/surrounded within/by another object or class and return the updated layer.</p> <p>This function is very helpful in applying the context-aware rules in classification.</p> <p>In this example, we define the new class \"Urban Vegetation\" if \"Vegetation\" is enclosed by \"Builtup\".</p>"},{"location":"examples/supervised_classification/#applying-touched_by-rule","title":"Applying Touched_by rule\u00b6","text":"<p>This rule is also applied based on class labels. This determines whether an object/segment is in direct contact with another object or class \u2014 that is, they share a boundary.</p> <p>This function is very useful in implementing context-aware rules in classification, especially when spatial relationships between features matter.</p> <p>In this example, we define a new class \"Builtup near WaterBodies\" if \"Builtup\" is touchedBy \"Water\".</p>"}]}